[
    {
        "id": "2720733497fe05f3",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": ""
    },
    {
        "id": "6f1d3aa6fc4865cc",
        "type": "subflow",
        "name": "Bounding Box Annotator",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 180,
                "wires": [
                    {
                        "id": "df99985d1f994959"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 1480,
                "y": 620,
                "wires": [
                    {
                        "id": "b0dac872bf034754",
                        "port": 0
                    },
                    {
                        "id": "96668e7ad6a75e0d",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "1279585c9501834e",
        "type": "mqtt-broker",
        "name": "",
        "broker": "broker",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "56f377808d863d71",
        "type": "ui_tab",
        "name": "Home",
        "icon": "dashboard",
        "disabled": false,
        "hidden": false
    },
    {
        "id": "4b3e41d9e35eaa2a",
        "type": "ui_base",
        "theme": {
            "name": "theme-light",
            "lightTheme": {
                "default": "#0094CE",
                "baseColor": "#0094CE",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": true,
                "reset": false
            },
            "darkTheme": {
                "default": "#097479",
                "baseColor": "#097479",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": false
            },
            "customTheme": {
                "name": "Untitled Theme 1",
                "default": "#4B7930",
                "baseColor": "#4B7930",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
            },
            "themeState": {
                "base-color": {
                    "default": "#0094CE",
                    "value": "#0094CE",
                    "edited": false
                },
                "page-titlebar-backgroundColor": {
                    "value": "#0094CE",
                    "edited": false
                },
                "page-backgroundColor": {
                    "value": "#fafafa",
                    "edited": false
                },
                "page-sidebar-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-textColor": {
                    "value": "#1bbfff",
                    "edited": false
                },
                "group-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "widget-textColor": {
                    "value": "#111111",
                    "edited": false
                },
                "widget-backgroundColor": {
                    "value": "#0094ce",
                    "edited": false
                },
                "widget-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "base-font": {
                    "value": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
                }
            },
            "angularTheme": {
                "primary": "indigo",
                "accents": "blue",
                "warn": "red",
                "background": "grey",
                "palette": "light"
            }
        },
        "site": {
            "name": "Node-RED Dashboard",
            "hideToolbar": "false",
            "allowSwipe": "false",
            "lockMenu": "false",
            "allowTempTheme": "true",
            "dateFormat": "DD/MM/YYYY",
            "sizes": {
                "sx": 48,
                "sy": 48,
                "gx": 6,
                "gy": 6,
                "cx": 6,
                "cy": 6,
                "px": 0,
                "py": 0
            }
        }
    },
    {
        "id": "64cdbc752e72aa52",
        "type": "ui_group",
        "name": "BBox Annotator",
        "tab": "56f377808d863d71",
        "order": 1,
        "disp": true,
        "width": "26",
        "collapse": false,
        "className": ""
    },
    {
        "id": "2aa5810f09721f8a",
        "type": "ui_group",
        "name": "BBox Annotator",
        "tab": "56f377808d863d71",
        "order": 1,
        "disp": true,
        "width": "26",
        "collapse": false,
        "className": ""
    },
    {
        "id": "dad3b5f695724c09",
        "type": "ui_tab",
        "name": "Home",
        "icon": "dashboard",
        "disabled": false,
        "hidden": false
    },
    {
        "id": "df99985d1f994959",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "extract frame from video source",
        "func": "flow.set(\"$parent.user_configuration\", msg.payload);\nflow.set(\"$parent.user_configuration_json_path\", \"/data/public/user_configuration/\" + msg.payload + \".json\");\nflow.set(\"$parent.user_configuration_target_json_path\", \"/data/public/user_configuration/target.json\");\nflow.set(\"$parent.user_configuration_image_path\", \"/data/public/images/\" + msg.payload + \".jpg\");\nflow.set(\"$parent.user_configuration_target_image_path\", \"/data/public/images/target.jpg\");\nmsg.payload = \"ffmpeg -y -i http://node-red:1880/videos/\" + msg.payload + \".mp4 -ss 00:00:01 -vframes 1 /data/public/images/\" + msg.payload + \".jpg\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 180,
        "wires": [
            [
                "9c29ce07761393c3"
            ]
        ]
    },
    {
        "id": "9c29ce07761393c3",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 450,
        "y": 180,
        "wires": [
            [
                "816c330835a613c7"
            ],
            [],
            []
        ]
    },
    {
        "id": "b9786d7c71690c77",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "copy configuration file to target path",
        "func": "var target_json_path = flow.get(\"$parent.user_configuration_target_json_path\");\nvar json_path = flow.get(\"$parent.user_configuration_json_path\");\nmsg.payload = \"cp \" + json_path + \" \" + target_json_path;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 180,
        "wires": [
            [
                "3a35f9c6c8521b1a"
            ]
        ]
    },
    {
        "id": "3a35f9c6c8521b1a",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1670,
        "y": 180,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "345bc96f5f851ecb",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "create new configuration file",
        "func": "msg.payload = { \"bboxes\": {} };\nmsg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 280,
        "wires": [
            [
                "eb824d410951906f"
            ]
        ]
    },
    {
        "id": "eb824d410951906f",
        "type": "file",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 1220,
        "y": 280,
        "wires": [
            [
                "b9786d7c71690c77"
            ]
        ]
    },
    {
        "id": "816c330835a613c7",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "copy image to target path",
        "func": "var target_image_path = flow.get(\"$parent.user_configuration_target_image_path\");\nvar image_path = flow.get(\"$parent.user_configuration_image_path\");\nmsg.payload = \"cp \" + image_path + \" \" + target_image_path;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 180,
        "wires": [
            [
                "f457658937757aa8"
            ]
        ]
    },
    {
        "id": "f457658937757aa8",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 810,
        "y": 180,
        "wires": [
            [
                "19cb7eb1ba17a59f"
            ],
            [],
            []
        ]
    },
    {
        "id": "aa47f138c69f2744",
        "type": "file in",
        "z": "6f1d3aa6fc4865cc",
        "name": "READ JSON",
        "filename": "filename",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 1230,
        "y": 180,
        "wires": [
            [
                "b9786d7c71690c77"
            ]
        ]
    },
    {
        "id": "19cb7eb1ba17a59f",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "check if configuration file exists",
        "func": "msg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 180,
        "wires": [
            [
                "aa47f138c69f2744"
            ]
        ]
    },
    {
        "id": "213a470553e48789",
        "type": "catch",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "scope": [
            "aa47f138c69f2744"
        ],
        "uncaught": false,
        "x": 810,
        "y": 280,
        "wires": [
            [
                "345bc96f5f851ecb"
            ]
        ]
    },
    {
        "id": "0e157a7ac6b4c0f6",
        "type": "ui_template",
        "z": "6f1d3aa6fc4865cc",
        "group": "64cdbc752e72aa52",
        "name": "",
        "order": 1,
        "width": "0",
        "height": "0",
        "format": "<div style=\"text-align: left;\">\n\t<canvas id=\"drawingCanvas\" width=\"1280\" height=\"720\" style=\"border:1px solid #000;\"></canvas>\n\t<div style=\"position: relative; z-index: 1;\">\n\t</div>\n\t<button onclick=\"addBbox()\">New Bbox</button>\n\t<button onclick=\"removeBbox()\">Remove Bbox</button>\n\t<button onclick=\"resetBbox()\">Reset Bbox</button>\n\t<button onclick=\"clearBbox()\">Clear Bbox</button>\n\t<button onclick=\"updateBbox()\">Save Bbox</button>\n\t<button onclick=\"storeInput()\">Click to Input Text</button>\n\t<input type=\"text\" id=\"userInput\" style=\"display: none;\" placeholder=\"Type something...\">\n\t<p id=\"displayText\"></p>\n</div>\n\n<div id=\"savePopupBox\"\n\tstyle=\"display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 1); padding: 20px; border-radius: 10px; z-index: 1000;\">\n\t<p style=\"color: black; font-size: 16px; font-weight: bold;\">\n\t\tConfiguration Saved!</p>\n</div>\n\n\n<script>\n\tlet targetBBoxData;\n\tlet handleSize = 10;\n\tlet drag = false;\n\tlet resize = [];\n\tlet bboxList = [];\n\tlet offsetX = [];\n\tlet offsetY = [];\n\tlet currentBboxName = \"not-set\";\n\tlet newBboxName = \"not-set\";\n\tconst canvas = document.getElementById(\"drawingCanvas\");\n\tconst ctx = canvas.getContext(\"2d\");\n\n\tresetBbox();\n\n\tconst new_img = new Image();\n\tnew_img.src = \"/images/target.jpg\"\n\tnew_img.onload = function() {\n\t  ctx.drawImage(new_img, 0, 0, canvas.width, canvas.height);\n\t  drawBBoxes(targetBBoxData.bboxes);\n\t};\n\t\n\tfunction drawBBoxes(bboxes) {\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\tctx.drawImage(new_img, 0, 0, canvas.width, canvas.height);\n\t\tObject.entries(bboxes).forEach(([bbox_name, bbox]) => {\n\t\t\tdrawHandles(bbox_name, bbox);\n\t\t})\n\t}\n  \n\tfunction activate_savepopup() {\n\t\tdocument.getElementById(\"savePopupBox\").style.display = \"block\";\n\t\tsetTimeout(close_savePopup, 2000);\n\t}\n\t\n\tfunction close_savePopup() {\n\t\tdocument.getElementById(\"savePopupBox\").style.display = \"none\";\n\t}\n\n\tfunction drawHandles(bbox_name, bbox) {\n\t\tctx.strokeStyle = 'orange';\n\t\tctx.lineWidth = 2;\n\t\t\n\t\t//\"vertex1\": {\"x\": 1, \"y\": 1}\n\t\tctx.beginPath();\n\t\tctx.moveTo(bbox.vertex1.x, bbox.vertex1.y);\n\t\tctx.lineTo(bbox.vertex2.x, bbox.vertex2.y);\n\t\tctx.lineTo(bbox.vertex4.x, bbox.vertex4.y);\n\t\tctx.lineTo(bbox.vertex3.x, bbox.vertex3.y);\n\t\tctx.lineTo(bbox.vertex1.x, bbox.vertex1.y);\n\t\tctx.closePath();\n\t\tctx.stroke();\n\t\tctx.fillStyle = 'red';\n\t\tctx.fillRect(bbox.vertex1.x - handleSize / 2, bbox.vertex1.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.vertex2.x - handleSize / 2, bbox.vertex2.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.vertex3.x - handleSize / 2, bbox.vertex3.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.vertex4.x - handleSize / 2, bbox.vertex4.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillStyle = 'yellow';\n\t\tctx.font = \"24px Arial\";\n\t\tctx.textAlign = \"center\";\n\t\tctx.fillText(bbox_name, bbox.vertex1.x, bbox.vertex1.y - handleSize);\n\t}\n  \n\tcanvas.addEventListener('mousedown', (e) => {\n\t\tlet mousePos = getMousePos(e, canvas);\n\t\tbboxList = [];\n\t\toffsetX = [];\n\t\toffsetY = [];\n\t\tresize = [];\n\t\tObject.entries(targetBBoxData.bboxes).reverse().forEach(([bbox_name, bbox]) => {\n\t\t\tif (isOnHandle(mousePos, bbox, 'top-left')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"top-left\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\tconsole.log(\"on Handle\");\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'top-right')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"top-right\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\tconsole.log(\"on Handle\");\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'bottom-left')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"bottom-left\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\tconsole.log(\"on Handle\");\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'bottom-right')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"bottom-right\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\tconsole.log(\"on Handle\");\n\t\t\t}\n\t\t})\n\n\t\tif (resize.length === 0) {\n\t\t\tObject.entries(targetBBoxData.bboxes).reverse().forEach(([bbox_name, bbox]) => {\n\t\t\t\tif (isInsideRect(mousePos, bbox)) {\n\t\t\t\t\tconsole.log(\"inside Rect\");\n\t\t\t\t\tdrag = true;\n\t\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\t\tvar tx1 = mousePos.x - bbox.vertex1.x;\n\t\t\t\t\tvar tx2 = mousePos.x - bbox.vertex2.x;\n\t\t\t\t\tvar tx3 = mousePos.x - bbox.vertex3.x;\n\t\t\t\t\tvar tx4 = mousePos.x - bbox.vertex4.x;\n\t\t\t\t\tvar ty1 = mousePos.y - bbox.vertex1.y;\n\t\t\t\t\tvar ty2 = mousePos.y - bbox.vertex2.y;\n\t\t\t\t\tvar ty3 = mousePos.y - bbox.vertex3.y;\n\t\t\t\t\tvar ty4 = mousePos.y - bbox.vertex4.y;\n\t\t\t\t\taddOffsetIfNotExists_4p(offsetX, offsetY, tx1, ty1, tx2, ty2, tx3, ty3, tx4, ty4);\n\t\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t});\n\n\tcanvas.addEventListener('mousemove', (e) => {\n\t\tlet mousePos = getMousePos(e, canvas);\n\t\tif (drag && bboxList.length > 0) {\n\t\t\tbboxList[0].vertex1.x = mousePos.x - offsetX[0][0];\n\t\t\tbboxList[0].vertex2.x = mousePos.x - offsetX[0][1];\n\t\t\tbboxList[0].vertex3.x = mousePos.x - offsetX[0][2];\n\t\t\tbboxList[0].vertex4.x = mousePos.x - offsetX[0][3];\n\t\t\tbboxList[0].vertex1.y = mousePos.y - offsetY[0][0];\n\t\t\tbboxList[0].vertex2.y = mousePos.y - offsetY[0][1];\n\t\t\tbboxList[0].vertex3.y = mousePos.y - offsetY[0][2];\n\t\t\tbboxList[0].vertex4.y = mousePos.y - offsetY[0][3];\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t}\n\t\tif (resize.length > 0 && bboxList.length > 0) {\n\t\t\tif (resize[0] === \"top-left\") {\n\t\t\t\tbboxList[0].vertex1.x = mousePos.x;\n\t\t\t\tbboxList[0].vertex1.y = mousePos.y;\n\t\t\t}\n\t\t\tif (resize[0] === \"top-right\") {\n\t\t\t\tbboxList[0].vertex2.x = mousePos.x;\n\t\t\t\tbboxList[0].vertex2.y = mousePos.y;\n\t\t\t}\n\t\t\tif (resize[0] === \"bottom-left\") { \n\t\t\t\tbboxList[0].vertex3.x = mousePos.x;\n\t\t\t\tbboxList[0].vertex3.y = mousePos.y;\n\t\t\t}\n\t\t\tif (resize[0] === \"bottom-right\") {\n\t\t\t\tbboxList[0].vertex4.x = mousePos.x;\n\t\t\t\tbboxList[0].vertex4.y = mousePos.y;\n\t\t\t}\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t}\n\t});\n\n\tcanvas.addEventListener('mouseup', () => {\n\t\tdrag = false;\n\t\tresize = [];\n\t});\n\n\tfunction getMousePos(evt, canvas) {\n\t\tconst canva_rect = canvas.getBoundingClientRect();\n\t\treturn {\n\t\t\tx: evt.clientX - canva_rect.left,\n\t\t\ty: evt.clientY - canva_rect.top\n\t\t};\n\t}\n\t\n\tfunction addBoxIfNotExists(bboxList, box) {\n\t\tif (!bboxList.includes(box)) {\n\t\t\tbboxList.push(box);\n\t\t}\n\t}\n\n\tfunction addOffsetIfNotExists(offsetX, offsetY, x, y) {\n\t\tif (!offsetX.includes(x)) {\n\t\t\toffsetX.push(x);\n\t\t\toffsetY.push(y);\n\t\t}\n\t}\n\n\tfunction addOffsetIfNotExists_4p(offsetX, offsetY, x1, y1, x2, y2, x3, y3, x4, y4) {\n\t\tif (!offsetX.includes([x1, x2, x3, x4])) {\n\t\t\toffsetX.push([x1, x2, x3, x4]);\n\t\t\toffsetY.push([y1, y2, y3, y4]);\n\t\t}\n\t}\n\t\n\tfunction addResizeIfNotExists(resize, x) {\n\t\tif (!resize.includes(x)) {\n\t\t\tresize.push(x);\n\t\t}\n\t}\n\n\tfunction isInsideRect(pos, bbox) {\n\t\tfunction crossProduct(x1, y1, x2, y2, x3, y3) {\n\t\t\treturn (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n\t\t}\n\t\tvar d1 = crossProduct(pos.x, pos.y, bbox.vertex1.x, bbox.vertex1.y, bbox.vertex2.x, bbox.vertex2.y);\n\t\tvar d2 = crossProduct(pos.x, pos.y, bbox.vertex2.x, bbox.vertex2.y, bbox.vertex4.x, bbox.vertex4.y);\n\t\tvar d3 = crossProduct(pos.x, pos.y, bbox.vertex4.x, bbox.vertex4.y, bbox.vertex3.x, bbox.vertex3.y);\n\t\tvar d4 = crossProduct(pos.x, pos.y, bbox.vertex3.x, bbox.vertex3.y, bbox.vertex1.x, bbox.vertex1.y);\n\t\tvar hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0) || (d4 < 0);\n\t\tvar hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0) || (d4 > 0);\n\t\treturn !(hasNeg && hasPos);\n\t}\n\t\n\tfunction isOnHandle(pos, rect, corner) {\n\t\tswitch (corner) {\n\t\t\tcase \"top-left\":\n\t\t\t\treturn pos.x > rect.vertex1.x - handleSize / 2 && pos.x < rect.vertex1.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.vertex1.y - handleSize / 2 && pos.y < rect.vertex1.y + handleSize / 2;\n\t\t\tcase \"top-right\":\n\t\t\t\treturn pos.x > rect.vertex2.x - handleSize / 2 && pos.x < rect.vertex2.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.vertex2.y - handleSize / 2 && pos.y < rect.vertex2.y + handleSize / 2;\n\t\t\tcase \"bottom-left\":\n\t\t\t\treturn pos.x > rect.vertex3.x - handleSize / 2 && pos.x < rect.vertex3.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.vertex3.y - handleSize / 2 && pos.y < rect.vertex3.y + handleSize / 2;\n\t\t\tcase \"bottom-right\":\n\t\t\t\treturn pos.x > rect.vertex4.x - handleSize / 2 && pos.x < rect.vertex4.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.vertex4.y - handleSize / 2 && pos.y < rect.vertex4.y + handleSize / 2;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction addBbox() {\n\t\ttargetBBoxData.bboxes[newBboxName] = { vertex1: {\"x\": 150, \"y\": 250},  vertex2: {\"x\": 350, \"y\": 250},\n\t\t\tvertex3: {\"x\": 150, \"y\": 450}, vertex4: {\"x\": 350, \"y\": 450}};\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\t\n\tfunction removeBbox() {\n\t\tdelete targetBBoxData.bboxes[currentBboxName];\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\n\tfunction resetBbox() {\n\t\tfetch('/user_configuration/target.json')\n\t\t.then(response => response.json())\n\t\t.then(data => {\n\t\t\ttargetBBoxData = data;\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t})\n\t\t.catch(error => console.error('Error loading JSON:', error));\n\t}\n\n\tfunction clearBbox() {\n\t\ttargetBBoxData = {\"bboxes\":{}};\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\t\n\tfunction updateBbox() {\n\t\tfetch(\"http://node-red:1880/user_configuration\", { //\n\t\t  method: \"POST\",\n\t\t  headers: {\n\t\t\t\"Content-Type\": \"application/json\"\n\t\t  },\n\t\t  body: JSON.stringify({ targetBBoxData })\n\t\t})\n\t\t.then(response => response.json())\n\t\t.then(data => console.log(\"Data sent to Node-RED:\", data))\n\t\t.catch(error => console.error(\"Error sending data:\", error));\n\t\tactivate_savepopup();\n\t  }\n\t\n\tfunction storeInput() {\n\t\tlet inputField = document.getElementById('userInput');\n\t\tinputField.style.display = 'inline';\n\t\tinputField.focus();\n\t\tconst handleEnter = function(event) {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tnewBboxName = inputField.value;\n\t\t\t\tinputField.style.display = 'none';\n\t\t\t\tinputField.value = '';\n\t\t\t\tinputField.removeEventListener('keypress', handleEnter); \n\t\t\t}\n\t\t};\n\t\tinputField.addEventListener('keypress', handleEnter);\n\t}\n  \n</script>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 120,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "976fdb34c4a8cb9e",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "html",
        "info": "",
        "x": 110,
        "y": 360,
        "wires": []
    },
    {
        "id": "e2bba08a4a54179d",
        "type": "file",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 680,
        "y": 560,
        "wires": [
            [
                "efc05a799d0eb099"
            ]
        ]
    },
    {
        "id": "b05b1e3d1cc4654a",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "save endpoint data to configuration file",
        "func": "msg.payload = msg.payload[\"targetBBoxData\"];\nmsg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 560,
        "wires": [
            [
                "e2bba08a4a54179d",
                "b0dac872bf034754"
            ]
        ]
    },
    {
        "id": "58424bf333efd3fe",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "save new parking lot data",
        "info": "",
        "x": 170,
        "y": 500,
        "wires": []
    },
    {
        "id": "efc05a799d0eb099",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "save configuration file to target file",
        "func": "msg.payload = \"cp \" + flow.get(\"$parent.user_configuration_json_path\") + \" \" + flow.get(\"$parent.user_configuration_target_json_path\");\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 560,
        "wires": [
            [
                "b656a7515c144c0e"
            ]
        ]
    },
    {
        "id": "b656a7515c144c0e",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1110,
        "y": 560,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "b0dac872bf034754",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "pre-processing data for dashboard use cases",
        "func": "let results = {};\nlet payload = msg.payload[\"bboxes\"];\n\nvar canvas_width = 1280;\nvar canvas_height = 720;\nvar video_pipeline_width = flow.get('$parent.video_pipeline_width');\nvar video_pipeline_height = flow.get('$parent.video_pipeline_height');\n\nvar scale_x = video_pipeline_width / canvas_width;\nvar scale_y = video_pipeline_height / canvas_height;\n\nfor (let key in payload) {\n    var vertex1 = { \"x\": payload[key][\"vertex1\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex1\"][\"y\"] * scale_y };\n    var vertex2 = { \"x\": payload[key][\"vertex2\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex2\"][\"y\"] * scale_y };\n    var vertex3 = { \"x\": payload[key][\"vertex4\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex4\"][\"y\"] * scale_y };\n    var vertex4 = { \"x\": payload[key][\"vertex3\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex3\"][\"y\"] * scale_y };\n    results[key] = { \"vertex1\": vertex1, \"vertex2\": vertex2, \"vertex3\": vertex3, \"vertex4\": vertex4 };\n}\n\nmsg.payload = results;\nmsg.bbox_name = flow.get(\"$parent.user_configuration\");\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "9ba81c2ec580b296",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "list config files",
        "func": "msg.payload = \"ls /data/public/user_configuration\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 740,
        "wires": [
            [
                "565ee24f2c20c513"
            ]
        ]
    },
    {
        "id": "565ee24f2c20c513",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 370,
        "y": 740,
        "wires": [
            [
                "308c4663480ec670"
            ],
            [],
            []
        ]
    },
    {
        "id": "f5306da2266ca53e",
        "type": "inject",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 660,
        "wires": [
            [
                "9ba81c2ec580b296"
            ]
        ]
    },
    {
        "id": "308c4663480ec670",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "excluding target files",
        "func": "let inputString = msg.payload;\n\nlet substrings = inputString.split(\"\\n\");\nconst stringToRemove = [\"target.json\", \"\"];\n\nsubstrings = substrings.filter(substring =>\n    !stringToRemove.includes(substring)\n);\n\nfor (let i = 0; i < substrings.length; i++) {\n    substrings[i] = \"/data/public/user_configuration/\" + substrings[i]\n}\n\nmsg.payload = substrings;\nmsg.filenames = substrings;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 740,
        "wires": [
            [
                "fdfab09a7c4051bd"
            ]
        ]
    },
    {
        "id": "fdfab09a7c4051bd",
        "type": "split",
        "z": "6f1d3aa6fc4865cc",
        "name": "Split File Paths",
        "splt": "",
        "spltType": "str",
        "arraySplt": "1",
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 740,
        "y": 740,
        "wires": [
            [
                "90125a488d1c55ca"
            ]
        ]
    },
    {
        "id": "90125a488d1c55ca",
        "type": "file in",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "payload",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 900,
        "y": 740,
        "wires": [
            [
                "96668e7ad6a75e0d"
            ]
        ]
    },
    {
        "id": "96668e7ad6a75e0d",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "pre-processing file data for dashboard use cases",
        "func": "msg.payload = JSON.parse(msg.payload);\n\nvar filePath = msg.filename;\nvar fileName = filePath.substring(filePath.lastIndexOf('/') + 1);\nfileName = fileName.substring(0, fileName.lastIndexOf('.'));\n\nlet results = {};\nlet payload = msg.payload[\"bboxes\"];\n\nvar canvas_width = 1280;\nvar canvas_height = 720;\nvar video_pipeline_width = flow.get('$parent.video_pipeline_width');\nvar video_pipeline_height = flow.get('$parent.video_pipeline_height');\n\nvar scale_x = video_pipeline_width / canvas_width;\nvar scale_y = video_pipeline_height / canvas_height;\n\nfor (let key in payload) {\n    var vertex1 = { \"x\": payload[key][\"vertex1\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex1\"][\"y\"] * scale_y };\n    var vertex2 = { \"x\": payload[key][\"vertex2\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex2\"][\"y\"] * scale_y };\n    var vertex3 = { \"x\": payload[key][\"vertex4\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex4\"][\"y\"] * scale_y }; // clockwise order\n    var vertex4 = { \"x\": payload[key][\"vertex3\"][\"x\"] * scale_x, \"y\": payload[key][\"vertex3\"][\"y\"] * scale_y };\n    results[key] = { \"vertex1\": vertex1, \"vertex2\": vertex2, \"vertex3\": vertex3, \"vertex4\": vertex4 };\n}\n\nmsg.payload = results;\nmsg.bbox_name = fileName;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "98e20d0688e95a58",
        "type": "http in",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "url": "/user_configuration",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 560,
        "wires": [
            [
                "b05b1e3d1cc4654a"
            ]
        ]
    },
    {
        "id": "0356ffb2221df2b0",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "frame extraction",
        "info": "",
        "x": 140,
        "y": 100,
        "wires": []
    },
    {
        "id": "501e241e7811f9b5",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "WARNING: please check you have started this container with a volume that is mounted to /data\\n otherwise any flow changes are lost when you redeploy or upgrade the container\\n (e.g. upgrade to a more recent node-red docker image).\\n  If you are using named volumes you can ignore this warning.\\n Double click or see info side panel to learn how to start Node-RED in Docker to save your work",
        "info": "\nTo start docker with a bind mount volume (-v option), for example:\n\n```\ndocker run -it -p : -v /home/user/node_red_data:/data --name mynodered nodered/node-red\n```\n\nwhere `/home/user/node_red_data` is a directory on your host machine where you want to store your flows.\n\nIf you do not do this then you can experiment and redploy flows, but if you restart or upgrade the container the flows will be disconnected and lost. \n\nThey will still exist in a hidden data volume, which can be recovered using standard docker techniques, but that is much more complex than just starting with a named volume as described above.",
        "x": 350,
        "y": 80,
        "wires": []
    },
    {
        "id": "65a15c78ceb22e7d",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 260,
        "wires": [
            [
                "6ba720d20cf575c4"
            ]
        ]
    },
    {
        "id": "c44e1f4281d8a475",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "Configurations",
        "info": "",
        "x": 150,
        "y": 200,
        "wires": []
    },
    {
        "id": "c3d158425536709b",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "user to upload video",
        "info": "",
        "x": 170,
        "y": 340,
        "wires": []
    },
    {
        "id": "10805e96612a105e",
        "type": "switch",
        "z": "2720733497fe05f3",
        "name": "",
        "property": "bbox_name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "VIRAT_S_000101",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "VIRAT_S_000101",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "VIRAT_S_000101",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "VIRAT_S_000101",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 670,
        "y": 400,
        "wires": [
            [
                "b254c3f9cb6cb475"
            ],
            [
                "1b77af1c801a0939"
            ],
            [
                "a6acf4385a1ff5c6"
            ],
            [
                "352813fda0fb5f36"
            ]
        ]
    },
    {
        "id": "2ced39b0bc78b88d",
        "type": "subflow:6f1d3aa6fc4865cc",
        "z": "2720733497fe05f3",
        "name": "Bounding Box Annotator",
        "x": 450,
        "y": 400,
        "wires": [
            [
                "10805e96612a105e"
            ]
        ]
    },
    {
        "id": "ceed697b9cbe6442",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_tracking_1",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 740,
        "wires": [
            [
                "3a0689e761c12ca9"
            ]
        ]
    },
    {
        "id": "95a42ca29a8157e7",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "payload": "VIRAT_S_000101",
        "payloadType": "str",
        "x": 190,
        "y": 400,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "b254c3f9cb6cb475",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "VIRAT_S_000101",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_1', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_1', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "56a313117a53b976",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "MQTT client live",
        "info": "",
        "x": 160,
        "y": 680,
        "wires": []
    },
    {
        "id": "729631300aafcecd",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "loiter_status_1",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1280,
        "y": 740,
        "wires": []
    },
    {
        "id": "1a2e768c9615a371",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 1140,
        "wires": [
            [
                "6d916de5b8fae1d9"
            ]
        ]
    },
    {
        "id": "6d916de5b8fae1d9",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "reset data",
        "func": "flow.set(\"object_detection_1\", {});\nflow.set(\"object_detection_2\", {});\nflow.set(\"object_detection_3\", {});\nflow.set(\"object_detection_4\", {});\nflow.set(\"previous_data_1\", {});\nflow.set(\"previous_data_2\", {});\nflow.set(\"previous_data_3\", {});\nflow.set(\"previous_data_4\", {});\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 1140,
        "wires": [
            []
        ]
    },
    {
        "id": "a823ac90efa8785f",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "reset data",
        "info": "",
        "x": 140,
        "y": 1080,
        "wires": []
    },
    {
        "id": "6ba720d20cf575c4",
        "type": "configurations",
        "z": "2720733497fe05f3",
        "name": "configurations 1",
        "func": "//Configurations\nlet target_object = [\"\"];\nlet video_pipeline_width = 1280;\nlet video_pipeline_height = 720;\nlet object_confidence = 0.1;\nlet intersection_type = \"object\"; // \"region\"\nlet intersection_threshold = 0.5;\nlet distance_threshold = 10000;\nlet object_counter = true;\n\n// loitering\nlet stop_duration = 30;\n\n/***************************/\n//Don't touch section below//\n/***************************/\nflow.set(\"target_object\", target_object);\nflow.set(\"video_pipeline_width\", video_pipeline_width);\nflow.set(\"video_pipeline_height\", video_pipeline_height);\nflow.set(\"object_confidence\", object_confidence);\nflow.set(\"intersection_type\", intersection_type);\nflow.set(\"intersection_threshold\", intersection_threshold);\nflow.set(\"distance_threshold\", distance_threshold);\nflow.set(\"object_counter\", object_counter);\n\n// loitering\nflow.set(\"stop_duration\", stop_duration);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "3a0689e761c12ca9",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 1",
        "func": "let payload = msg.payload[\"metadata\"][\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get(\"object_confidence\");\nvar target_object = flow.get(\"target_object\");\nvar stop_duration = flow.get(\"stop_duration\");\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"Asia/Kuala_Lumpur\" }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, \"0\");\nvar dates = (localDate.getDate()).toString().padStart(2, \"0\");\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = (\"0\" + hours).slice(-2);\nminutes = (\"0\" + minutes).slice(-2);\nseconds = (\"0\" + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + \":\" + minutes + \":\" + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty(\"detection\")) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key][\"roi_type\"] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key][\"detection\"][\"confidence\"] > object_confidence) {\n            var current_object_data = {\n                \"bbox\": {\n                    \"vertex1\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] },\n                    \"vertex2\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] },\n                    \"vertex3\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex4\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex_0\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] }\n                }\n            }\n            if (payload[key].hasOwnProperty(\"type\") && payload[key][\"type\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"type\"] = payload[key][\"type\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"color\") && payload[key][\"color\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"color\"] = payload[key][\"color\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"license_plate\") && payload[key][\"license_plate\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"license_plate\"] = payload[key][\"license_plate\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"id\")) {\n                current_object_data[\"id\"] = payload[key][\"id\"];\n            }\n            if (payload[key].hasOwnProperty(\"roi_type\")) {\n                current_object_data[\"roi_type\"] = payload[key][\"roi_type\"];\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 740,
        "wires": [
            [
                "6d1397cf65bda6aa"
            ]
        ]
    },
    {
        "id": "a1f6b26eef5ac68f",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_tracking_2",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 820,
        "wires": [
            [
                "63ed08c9d9d94185"
            ]
        ]
    },
    {
        "id": "3fd8b749f4a0e307",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "loiter_status_2",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1280,
        "y": 820,
        "wires": []
    },
    {
        "id": "63ed08c9d9d94185",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 2",
        "func": "let payload = msg.payload[\"metadata\"][\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get(\"object_confidence\");\nvar target_object = flow.get(\"target_object\");\nvar stop_duration = flow.get(\"stop_duration\");\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"Asia/Kuala_Lumpur\" }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, \"0\");\nvar dates = (localDate.getDate()).toString().padStart(2, \"0\");\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = (\"0\" + hours).slice(-2);\nminutes = (\"0\" + minutes).slice(-2);\nseconds = (\"0\" + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + \":\" + minutes + \":\" + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty(\"detection\")) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key][\"roi_type\"] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key][\"detection\"][\"confidence\"] > object_confidence) {\n            var current_object_data = {\n                \"bbox\": {\n                    \"vertex1\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] },\n                    \"vertex2\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] },\n                    \"vertex3\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex4\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex_0\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] }\n                }\n            }\n            if (payload[key].hasOwnProperty(\"type\") && payload[key][\"type\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"type\"] = payload[key][\"type\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"color\") && payload[key][\"color\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"color\"] = payload[key][\"color\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"license_plate\") && payload[key][\"license_plate\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"license_plate\"] = payload[key][\"license_plate\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"id\")) {\n                current_object_data[\"id\"] = payload[key][\"id\"];\n            }\n            if (payload[key].hasOwnProperty(\"roi_type\")) {\n                current_object_data[\"roi_type\"] = payload[key][\"roi_type\"];\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 820,
        "wires": [
            [
                "13f8c2a94ffb9426"
            ]
        ]
    },
    {
        "id": "1ac404d98d97fa69",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_tracking_3",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 900,
        "wires": [
            [
                "d928b5e30373e729"
            ]
        ]
    },
    {
        "id": "9087d04b7d7896a2",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "loiter_status_3",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1280,
        "y": 900,
        "wires": []
    },
    {
        "id": "d928b5e30373e729",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 3",
        "func": "let payload = msg.payload[\"metadata\"][\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get(\"object_confidence\");\nvar target_object = flow.get(\"target_object\");\nvar stop_duration = flow.get(\"stop_duration\");\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"Asia/Kuala_Lumpur\" }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, \"0\");\nvar dates = (localDate.getDate()).toString().padStart(2, \"0\");\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = (\"0\" + hours).slice(-2);\nminutes = (\"0\" + minutes).slice(-2);\nseconds = (\"0\" + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + \":\" + minutes + \":\" + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty(\"detection\")) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key][\"roi_type\"] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key][\"detection\"][\"confidence\"] > object_confidence) {\n            var current_object_data = {\n                \"bbox\": {\n                    \"vertex1\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] },\n                    \"vertex2\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] },\n                    \"vertex3\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex4\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex_0\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] }\n                }\n            }\n            if (payload[key].hasOwnProperty(\"type\") && payload[key][\"type\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"type\"] = payload[key][\"type\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"color\") && payload[key][\"color\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"color\"] = payload[key][\"color\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"license_plate\") && payload[key][\"license_plate\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"license_plate\"] = payload[key][\"license_plate\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"id\")) {\n                current_object_data[\"id\"] = payload[key][\"id\"];\n            }\n            if (payload[key].hasOwnProperty(\"roi_type\")) {\n                current_object_data[\"roi_type\"] = payload[key][\"roi_type\"];\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 900,
        "wires": [
            [
                "4e43313da371d101"
            ]
        ]
    },
    {
        "id": "c94cf3a6c2ae83d9",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_tracking_4",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 980,
        "wires": [
            [
                "f3db59aeda44d700"
            ]
        ]
    },
    {
        "id": "1bcfe855226bfbaf",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "loiter_status_4",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1280,
        "y": 980,
        "wires": []
    },
    {
        "id": "f3db59aeda44d700",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 4",
        "func": "let payload = msg.payload[\"metadata\"][\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get(\"object_confidence\");\nvar target_object = flow.get(\"target_object\");\nvar stop_duration = flow.get(\"stop_duration\");\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"Asia/Kuala_Lumpur\" }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, \"0\");\nvar dates = (localDate.getDate()).toString().padStart(2, \"0\");\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = (\"0\" + hours).slice(-2);\nminutes = (\"0\" + minutes).slice(-2);\nseconds = (\"0\" + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + \":\" + minutes + \":\" + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty(\"detection\")) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key][\"roi_type\"] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key][\"detection\"][\"confidence\"] > object_confidence) {\n            var current_object_data = {\n                \"bbox\": {\n                    \"vertex1\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] },\n                    \"vertex2\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] },\n                    \"vertex3\": { \"x\": payload[key][\"x\"] + payload[key][\"w\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex4\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] + payload[key][\"h\"] },\n                    \"vertex_0\": { \"x\": payload[key][\"x\"], \"y\": payload[key][\"y\"] }\n                }\n            }\n            if (payload[key].hasOwnProperty(\"type\") && payload[key][\"type\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"type\"] = payload[key][\"type\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"color\") && payload[key][\"color\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"color\"] = payload[key][\"color\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"license_plate\") && payload[key][\"license_plate\"].hasOwnProperty(\"label\")) {\n                current_object_data[\"license_plate\"] = payload[key][\"license_plate\"][\"label\"];\n            }\n            if (payload[key].hasOwnProperty(\"id\")) {\n                current_object_data[\"id\"] = payload[key][\"id\"];\n            }\n            if (payload[key].hasOwnProperty(\"roi_type\")) {\n                current_object_data[\"roi_type\"] = payload[key][\"roi_type\"];\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 980,
        "wires": [
            [
                "c4a9ee507bb7935f"
            ]
        ]
    },
    {
        "id": "b2f96ffd1368e6f6",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0.2",
        "topic": "",
        "payload": "VIRAT_S_000101",
        "payloadType": "str",
        "x": 190,
        "y": 460,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "1b8bcffa5603bdd2",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0.2",
        "topic": "",
        "payload": "VIRAT_S_000101",
        "payloadType": "str",
        "x": 190,
        "y": 520,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "48b6760a5e9e7bfc",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0.2",
        "topic": "",
        "payload": "VIRAT_S_000101",
        "payloadType": "str",
        "x": 190,
        "y": 580,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "1b77af1c801a0939",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "VIRAT_S_000101",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_2', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_2', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "a6acf4385a1ff5c6",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "VIRAT_S_000101",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_3', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_3', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "352813fda0fb5f36",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "VIRAT_S_000101",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_4', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_4', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "093ff9cee8868aab",
        "type": "delay",
        "z": "2720733497fe05f3",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1100,
        "y": 740,
        "wires": [
            [
                "729631300aafcecd"
            ]
        ]
    },
    {
        "id": "39dc4cfc10b8c436",
        "type": "delay",
        "z": "2720733497fe05f3",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1100,
        "y": 820,
        "wires": [
            [
                "3fd8b749f4a0e307"
            ]
        ]
    },
    {
        "id": "8405f44e1ba1f8b8",
        "type": "delay",
        "z": "2720733497fe05f3",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1100,
        "y": 900,
        "wires": [
            [
                "9087d04b7d7896a2"
            ]
        ]
    },
    {
        "id": "56574ab7de3a4719",
        "type": "delay",
        "z": "2720733497fe05f3",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1100,
        "y": 980,
        "wires": [
            [
                "1bcfe855226bfbaf"
            ]
        ]
    },
    {
        "id": "deb240b2b63ec5ac",
        "type": "multi streams",
        "z": "2720733497fe05f3",
        "name": "multi streams 1",
        "func": "var object_detection_list = [\n    flow.get('object_detection_1'),\n    flow.get('object_detection_2'),\n    flow.get('object_detection_3'),\n    flow.get('object_detection_4'),\n    //Add more\n];\n\nvar result = { \"payload\": {} };\nvar region_index = 0;\nvar status = true;\n\nfor (let i = 0; i < object_detection_list.length; i++) {\n    if (!object_detection_list[i])\n    {\n        status = false;\n        break;\n    }\n\n    if (typeof object_detection_list[i].payload == 'string') {\n        object_detection_list[i].payload = JSON.parse(object_detection_list[i].payload)\n    }\n}\n\nif (status == false) {\n    return result;\n}\n\nfor (let i = 0; i < object_detection_list.length; i++) {\n    var keys = Object.keys(object_detection_list[i].payload);\n\n    for (let j = 0; j < keys.length; j++) {\n        if (!result.payload[\"Region \" + (region_index + 1)]) {\n            result.payload[\"Region \" + (region_index + 1)] = {};\n            result.payload[\"Region \" + (region_index + 1)] = object_detection_list[i].payload[keys[j]];\n        }\n        region_index++;\n    }\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1060,
        "wires": [
            [
                "fa8d87c69d6ecbc7"
            ]
        ]
    },
    {
        "id": "2441fa726b3137c8",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "loiter_status_total",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1510,
        "y": 1060,
        "wires": []
    },
    {
        "id": "fded0e73f24f4063",
        "type": "delay",
        "z": "2720733497fe05f3",
        "name": "",
        "pauseType": "delay",
        "timeout": "0",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1320,
        "y": 1060,
        "wires": [
            [
                "2441fa726b3137c8"
            ]
        ]
    },
    {
        "id": "6d1397cf65bda6aa",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 1",
        "func": "let region_name = 'predefined_regions_1';\nlet detection_name = 'object_detection_1';\nlet previous_data_name = 'previous_data_1';\nlet occupancy_check_duration = 60;\nlet video_id = 1;\nlet region_id = 1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\nvar stop_duration = flow.get(\"stop_duration\");\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty(\"type\")) {\n            current_object_data[\"type\"] = object_data[\"type\"];\n        }\n        if (object_data.hasOwnProperty(\"color\")) {\n            current_object_data[\"color\"] = object_data[\"color\"];\n        }\n        if (object_data.hasOwnProperty(\"license_plate\")) {\n            current_object_data[\"license_plate\"] = object_data[\"license_plate\"];\n        }\n        if (object_data.hasOwnProperty(\"id\")) {\n            current_object_data[\"id\"] = object_data[\"id\"];\n        }\n        if (object_data.hasOwnProperty(\"roi_type\")) {\n            current_object_data[\"roi_type\"] = object_data[\"roi_type\"];\n        }\n        return current_object_data;\n    }\n    function getLotBbox(lot_data) {\n        return { \"vertex1\": lot_data.vertex1, \"vertex2\": lot_data.vertex2, \"vertex3\": lot_data.vertex3, \"vertex4\": lot_data.vertex4, \"vertex_0\": lot_data.vertex1 };\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var objectData = getObjectData(payload[key]);\n            if (objectData !== null) {\n                objects_extra.push(\n                    objectData\n                );\n                objects.push(\n                    payload[key][\"bbox\"]\n                );\n            }\n        }\n    }\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    function getBboxCentroid(bbox) {\n        var centroid_x = (bbox[\"vertex1\"].x + bbox[\"vertex2\"].x + bbox[\"vertex3\"].x + bbox[\"vertex4\"].x) / 4;\n        var centroid_y = (bbox[\"vertex1\"].y + bbox[\"vertex2\"].y + bbox[\"vertex3\"].y + bbox[\"vertex4\"].y) / 4;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIntersectArea(bbox1, bbox2) { // objects, lots\n        var bbox1_key = Object.keys(bbox1)\n        var bbox2_key = Object.keys(bbox2)\n        var intersection = [];\n\n        for (let i = 0; i < bbox1_key.length - 1; i++) {\n            for (let j = 0; j < bbox2_key.length - 1; j++) {\n                var A1 = bbox1[bbox1_key[i + 1]].y - bbox1[bbox1_key[i]].y; // Ax + By + C = 0\n                var B1 = bbox1[bbox1_key[i]].x - bbox1[bbox1_key[i + 1]].x;\n                var C1 = - A1 * bbox1[bbox1_key[i]].x - B1 * bbox1[bbox1_key[i]].y;\n\n                var A2 = bbox2[bbox2_key[j + 1]].y - bbox2[bbox2_key[j]].y;\n                var B2 = bbox2[bbox2_key[j]].x - bbox2[bbox2_key[j + 1]].x;\n                var C2 = - A2 * bbox2[bbox2_key[j]].x - B2 * bbox2[bbox2_key[j]].y;\n\n                // parallel lines case\n                if (A1 * B2 == A2 * B1) {\n                    // coincide case\n                    if ((A1 * C2 == A2 * C1) && (B1 * C2 == B2 * C1)) {\n                        if (B1 == 0 && A1 == 0) { // one point bbox case\n                            intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B2 == 0 && A2 == 0) { // one point bbox case\n                            intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B1 == 0) { // vertical lines case\n                            var y_min1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i]].y : bbox1[bbox1_key[i + 1]].y;\n                            var y_max1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i + 1]].y : bbox1[bbox1_key[i]].y;\n                            var y_min2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i]].y : bbox2[bbox2_key[i + 1]].y;\n                            var y_max2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i + 1]].y : bbox2[bbox2_key[i]].y;\n                            if ((y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var y_min = (y_min1 < y_min2) ? y_min2 : y_min1;\n                                var y_max = (y_max1 < y_max2) ? y_max1 : y_max2;\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_min.toFixed(6)]);\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_max.toFixed(6)]);\n                            }\n                        }\n                        else if (A1 == 0) { // horizontal lines case\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                intersection.push([x_min.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                            }\n                        }\n                        else {\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1) && (y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                var xY_min = (-A1 * x_min - C1) / B1\n                                var xY_max = (-A1 * x_max - C1) / B1\n                                intersection.push([x_min.toFixed(6), xY_min.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), xY_max.toFixed(6)]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // get intersection coordinates\n                    var x1 = bbox1[bbox1_key[i]].x;\n                    var x2 = bbox1[bbox1_key[i + 1]].x;\n                    var x3 = bbox2[bbox2_key[j]].x;\n                    var x4 = bbox2[bbox2_key[j + 1]].x;\n                    var y1 = bbox1[bbox1_key[i]].y;\n                    var y2 = bbox1[bbox1_key[i + 1]].y;\n                    var y3 = bbox2[bbox2_key[j]].y;\n                    var y4 = bbox2[bbox2_key[j + 1]].y;\n\n                    var den = (x2 - x1) * (y3 - y4) - (y2 - y1) * (x3 - x4);\n                    var t = ((x3 - x1) * (y3 - y4) - (y3 - y1) * (x3 - x4)) / den;\n                    var u = ((x3 - x1) * (y1 - y2) - (y3 - y1) * (x1 - x2)) / den;\n                    if ((t >= 0) && (t <= 1) && (u >= 0) && (u <= 1)) { // intersect happens if this condition is fulfilled\n                        var ix = x1 + t * (x2 - x1);\n                        var iy = y1 + t * (y2 - y1);\n                        intersection.push([ix.toFixed(6), iy.toFixed(6)]);\n                    }\n                }\n            }\n        }\n        // get clipped coordinates\n        var specialcase1 = true;\n        var specialcase2 = false;\n        var temp1 = bbox1[bbox1_key[0]];\n        var temp2 = bbox2[bbox2_key[0]];\n        for (let i = 1; i < bbox1_key.length - 1; i++) { // special case\n            if (temp1 !== bbox1[bbox1_key[i]]) {\n                specialcase1 = false;\n                break;\n            }\n        }\n        for (let i = 1; i < bbox2_key.length - 1; i++) {\n            if (temp2 !== bbox2[bbox2_key[i]]) {\n                specialcase2 = false;\n                break;\n            }\n        }\n        if (!(specialcase2)) {\n            for (let i = 0; i < bbox1_key.length - 1; i++) {\n                var sign_check = [];\n                for (let j = 0; j < bbox2_key.length - 1; j++) {\n                    var x1 = bbox2[bbox2_key[j]].x\n                    var x2 = bbox2[bbox2_key[j + 1]].x\n                    var y1 = bbox2[bbox2_key[j]].y\n                    var y2 = bbox2[bbox2_key[j + 1]].y\n                    var cross_prod = (bbox1[bbox1_key[i]].x - x1) * (y2 - y1) - (bbox1[bbox1_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) { // similar signs indicate the coordinate is within another bbox\n                    intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox1[bbox1_key[i]].x, bbox1[bbox1_key[i]].y]);\n                }\n            }\n        }\n        if (!(specialcase1)) {\n            for (let i = 0; i < bbox2_key.length - 1; i++) { // similar purpose but for second bbox\n                var sign_check = [];\n                for (let j = 0; j < bbox1_key.length - 1; j++) {\n                    var x1 = bbox1[bbox1_key[j]].x\n                    var x2 = bbox1[bbox1_key[j + 1]].x\n                    var y1 = bbox1[bbox1_key[j]].y\n                    var y2 = bbox1[bbox1_key[j + 1]].y\n                    var cross_prod = (bbox2[bbox2_key[i]].x - x1) * (y2 - y1) - (bbox2[bbox2_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) {\n                    intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox2[bbox2_key[i]].x, bbox2[bbox2_key[i]].y]);\n                }\n            }\n        }\n        intersection = intersection.filter((item, index, self) =>\n            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(item))\n        );\n        // sort intersection points\n        if (intersection.length > 2) {\n            var intersection_angle = [];\n            var intersection_distance = [];\n\n            let minIndex = intersection.reduce((minIdx, currentValue, currentIndex, array) => {\n                if (currentValue[0] < array[minIdx][0]) {\n                    return currentIndex;\n                } else if (currentValue[0] === array[minIdx][0]) {\n                    return currentValue[1] < array[minIdx][1] ? currentIndex : minIdx;\n                } else {\n                    return minIdx;\n                }\n            }, 0);\n            var temp_intersection = intersection.filter((_, index) => index !== minIndex);\n            for (let i = 0; i < temp_intersection.length; i++) {\n                intersection_angle.push(Math.atan2(temp_intersection[i][1] - intersection[minIndex][1], temp_intersection[i][0] - intersection[minIndex][0]));\n                intersection_distance.push((temp_intersection[i][1] - intersection[minIndex][1]) ** 2 + (temp_intersection[i][0] - intersection[minIndex][0]) ** 2);\n            }\n            let combined = temp_intersection.map((point, index) => ({ // sort intersect coordinates based on angle and then distance\n                point: point,\n                angle: intersection_angle[index],\n                distance: intersection_distance[index]\n            }));\n            combined.sort((a, b) => a.angle - b.angle || a.distance - b.distance);\n            let sorted_intersection = combined.map(item => item.point);\n            sorted_intersection.unshift(intersection[minIndex]);\n            sorted_intersection.push(intersection[minIndex]);\n            // shoelace algorithm to calculate the intersect area\n            var area = 0;\n            for (let i = 0; i < sorted_intersection.length - 1; i++) {\n                area += ((sorted_intersection[i][0] * sorted_intersection[i + 1][1])\n                    - (sorted_intersection[i + 1][0] * sorted_intersection[i][1]))\n            }\n            return area;\n        }\n        return 0;\n    }\n    function calculateIOU(bbox1, bbox2, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area1 = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n\n            var lot_area2 = (bbox2[\"vertex1\"].x * bbox2[\"vertex2\"].y) + (bbox2[\"vertex2\"].x * bbox2[\"vertex3\"].y)\n                + (bbox2[\"vertex3\"].x * bbox2[\"vertex4\"].y) + (bbox2[\"vertex4\"].x * bbox2[\"vertex_0\"].y)\n                - ((bbox2[\"vertex2\"].x * bbox2[\"vertex1\"].y) + (bbox2[\"vertex3\"].x * bbox2[\"vertex2\"].y)\n                    + (bbox2[\"vertex4\"].x * bbox2[\"vertex3\"].y) + (bbox2[\"vertex_0\"].x * bbox2[\"vertex4\"].y));\n            return intersectArea / (lot_area1 + lot_area2 - intersectArea)\n        }\n        return 0;\n    }\n    function calculateIOR(bbox1, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n            return intersectArea / lot_area;\n        }\n        return 0;\n    }\n\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({ \"occupied\": 0 });\n        }\n    }\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) { // find all lots within the object centroid distance threshold\n            var objectCentroid = getBboxCentroid(payload[\"objects\"][key1]);\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getBboxCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // calculate IOU or IOR\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        var IOR = 0;\n                        if (intersection_type == \"region\") {\n                            IOR = calculateIOR(payload[\"lots\"][i], intersectRegion)\n                        }\n                        else if (intersection_type == \"object\") {\n                            IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                        }\n                        if (IOR > intersection_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            else { // consider the best lot only\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    var IOR = 0;\n                    if (intersection_type == \"region\") {\n                        IOR = calculateIOR(payload[\"lots\"][best_region_index], intersectRegion)\n                    }\n                    else if (intersection_type == \"object\") {\n                        IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                    }\n                    if (IOR > intersection_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied;\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        results = initializeResults(results, occupied, i);\n        previous_data = initializePreviousData(results, i);\n        if (results[\"Region \" + (i + 1)].hasOwnProperty(\"id\") || previous_data[\"Region \" + (i + 1)].hasOwnProperty(\"id\")) {\n            results = handleObjectWithID(results, i);\n        }\n        else if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            results = handleOccupiedRegion(results, i);\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results = handleNotOccupiedRegion(results, i);\n        }\n    }\n    return results;\n}\n\nfunction initializeResults(results, occupied, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    if (!results[regionKey]) {\n        results[regionKey] = {};\n    }\n    results[regionKey][\"video_id\"] = video_id;\n    results[regionKey][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n    if (occupied[i].hasOwnProperty(\"occupied\")) {\n        results[regionKey][\"occupied\"] = occupied[i].occupied;\n    }\n\n    if (occupied[i].hasOwnProperty(\"extra\")) {\n        for (let key in occupied[i].extra) {\n            results[regionKey][key] = occupied[i].extra[key];\n        }\n    }\n    if (results[regionKey].hasOwnProperty(\"id\") || (previous_data && previous_data.hasOwnProperty(regionKey) && previous_data[regionKey].hasOwnProperty(\"id\"))) {\n        results[regionKey][\"actual_entry_time\"] = [];\n        results[regionKey][\"actual_dwell_time\"] = [];\n        results[regionKey][\"entry_time\"] = [];\n        results[regionKey][\"dwell_time\"] = [];\n        results[regionKey][\"exit_time\"] = [];\n    }\n    else {\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"actual_dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"exit_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n    }\n    return results;\n}\n\nfunction initializePreviousData(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    // Ensure previous_data is set up for this region.\n    if (!previous_data) {\n        previous_data = {};\n    }\n    if (results[regionKey].hasOwnProperty(\"id\")) {\n        if (!previous_data[regionKey]) {\n            previous_data[regionKey] = {};\n            previous_data[regionKey][\"id\"] = [];\n            previous_data[regionKey][\"actual_entry_time\"] = [];\n            previous_data[regionKey][\"actual_dwell_time\"] = [];\n            previous_data[regionKey][\"entry_time\"] = [];\n            previous_data[regionKey][\"dwell_time\"] = [];\n            previous_data[regionKey][\"exit_time\"] = [];\n        }\n    }\n    else {\n        if (!previous_data.hasOwnProperty(regionKey)) {\n            previous_data[regionKey] = results[regionKey];\n            previous_data[regionKey][\"actual_entry_time\"] = \"\";\n            previous_data[regionKey][\"actual_dwell_time\"] = \"\";\n            previous_data[regionKey][\"entry_time\"] = \"\";\n            previous_data[regionKey][\"dwell_time\"] = \"\";\n            previous_data[regionKey][\"exit_time\"] = \"\";\n            previous_data[regionKey][\"occupancy_check\"] = 0;\n        }\n    }\n\n    return previous_data;\n}\n\nfunction handleObjectWithID(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    const resultIds = results[regionKey][\"id\"];\n    const previousDataIds = previous_data[regionKey][\"id\"];\n\n    if (!resultIds && !previousDataIds) {\n        return results;\n    }\n\n    if (resultIds) {\n        for (let j = 0; j < resultIds.length; j++) {\n            // Check existing id data\n            let prevIndex = -1;\n\n            if (previous_data[regionKey][\"id\"] && previous_data[regionKey][\"id\"].length > 0) {\n                prevIndex = previous_data[regionKey][\"id\"].indexOf(resultIds[j]);\n            }\n\n            if (prevIndex === -1) {\n                results[regionKey][\"actual_entry_time\"].push(msg.nodered_timestamp);\n                results[regionKey][\"entry_time\"].push(msg.object_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(\"00:00:00\");\n                results[regionKey][\"dwell_time\"].push(0);\n                results[regionKey][\"exit_time\"].push(\"\");\n            } else {\n                results[regionKey][\"actual_entry_time\"].push(previous_data[regionKey][\"actual_entry_time\"][prevIndex]);\n                results[regionKey][\"entry_time\"].push(previous_data[regionKey][\"entry_time\"][prevIndex]);\n\n                // Calculate dwell time.\n                const dwell_timestamp = (msg.object_timestamp - results[regionKey][\"entry_time\"][j]);\n                const dwell_hours = Math.floor(dwell_timestamp / 3600).toString().padStart(2, \"0\");\n                const dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n                const dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n                results[regionKey][\"dwell_time\"].push(dwell_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds);\n                results[regionKey][\"exit_time\"].push(\"\");\n            }\n        }\n    }\n\n    if (previousDataIds) {\n        for (let j = 0; j < previousDataIds.length; j++) {\n            let prevIndex = -1;\n\n            if (!results[regionKey][\"id\"]) {\n                results[regionKey] = previous_data[regionKey];\n                results[regionKey][\"occupied\"] = 0;\n                break;\n            }\n            else {\n                if (!results[regionKey][\"dwell_time\"].some(val => val >= stop_duration)) {\n                    results[regionKey][\"occupied\"] = 0;\n                }\n\n                prevIndex = results[regionKey][\"id\"].indexOf(previousDataIds[j]);\n                if (prevIndex === -1) {\n                    let keyList = Object.keys(previous_data[regionKey]);\n                    for (let k = 0; k < keyList.length; k++) {\n                        if (keyList[k] == \"video_id\" || keyList[k] == \"region_id\" || keyList[k] == \"occupied\") {\n                            continue;\n                        }\n                        results[regionKey][keyList[k]].push(previous_data[regionKey][keyList[k]][j]);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction handleOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    if (previous_data[regionKey][\"entry_time\"] == \"\") {\n        results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n        results[regionKey][\"entry_time\"] = msg.object_timestamp;\n    }\n    else {\n        if (previous_data[regionKey][\"occupancy_check\"] >= occupancy_check_duration) {\n            results[regionKey][\"actual_dwell_time\"] = \"00:00:00\";\n            results[regionKey][\"dwell_time\"] = 0;\n            results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n            results[regionKey][\"entry_time\"] = msg.object_timestamp;\n        }\n        else {\n            results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n            results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n        }\n\n        var dwell_timestamp = msg.object_timestamp - results[regionKey][\"entry_time\"];\n        var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n        dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, \"0\") : dwell_hours.toString();\n        var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n        var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n\n        results[regionKey][\"dwell_time\"] = dwell_timestamp;\n        results[regionKey][\"actual_dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n        results[regionKey][\"occupancy_check\"] = 0;\n    }\n\n    return results;\n}\n\nfunction handleNotOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n    results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n    results[regionKey][\"actual_dwell_time\"] = previous_data[regionKey][\"actual_dwell_time\"];\n    results[regionKey][\"dwell_time\"] = previous_data[regionKey][\"dwell_time\"];\n    results[regionKey][\"occupancy_check\"] = previous_data[regionKey][\"occupancy_check\"] + 1;\n\n    if (previous_data[regionKey][\"exit_time\"]) {\n        results[regionKey][\"exit_time\"] = previous_data[regionKey][\"exit_time\"];\n    }\n    else {\n        results[regionKey][\"exit_time\"] = msg.nodered_timestamp;\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, intersection_type, intersection_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get(\"distance_threshold\");\nvar intersection_type = flow.get(\"intersection_type\");\nvar intersection_threshold = flow.get(\"intersection_threshold\");\nvar object_counter = flow.get(\"object_counter\");\n\nmsg.payload = main(payload, distance_threshold, intersection_type, intersection_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 740,
        "wires": [
            [
                "f8d561d7209fefb6",
                "deb240b2b63ec5ac"
            ]
        ]
    },
    {
        "id": "13f8c2a94ffb9426",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 2",
        "func": "let region_name = 'predefined_regions_2';\nlet detection_name = 'object_detection_2';\nlet previous_data_name = 'previous_data_2';\nlet occupancy_check_duration = 60;\nlet video_id = 2;\nlet region_id = 1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\nvar stop_duration = flow.get(\"stop_duration\");\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty(\"type\")) {\n            current_object_data[\"type\"] = object_data[\"type\"];\n        }\n        if (object_data.hasOwnProperty(\"color\")) {\n            current_object_data[\"color\"] = object_data[\"color\"];\n        }\n        if (object_data.hasOwnProperty(\"license_plate\")) {\n            current_object_data[\"license_plate\"] = object_data[\"license_plate\"];\n        }\n        if (object_data.hasOwnProperty(\"id\")) {\n            current_object_data[\"id\"] = object_data[\"id\"];\n        }\n        if (object_data.hasOwnProperty(\"roi_type\")) {\n            current_object_data[\"roi_type\"] = object_data[\"roi_type\"];\n        }\n        return current_object_data;\n    }\n    function getLotBbox(lot_data) {\n        return { \"vertex1\": lot_data.vertex1, \"vertex2\": lot_data.vertex2, \"vertex3\": lot_data.vertex3, \"vertex4\": lot_data.vertex4, \"vertex_0\": lot_data.vertex1 };\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var objectData = getObjectData(payload[key]);\n            if (objectData !== null) {\n                objects_extra.push(\n                    objectData\n                );\n                objects.push(\n                    payload[key][\"bbox\"]\n                );\n            }\n        }\n    }\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    function getBboxCentroid(bbox) {\n        var centroid_x = (bbox[\"vertex1\"].x + bbox[\"vertex2\"].x + bbox[\"vertex3\"].x + bbox[\"vertex4\"].x) / 4;\n        var centroid_y = (bbox[\"vertex1\"].y + bbox[\"vertex2\"].y + bbox[\"vertex3\"].y + bbox[\"vertex4\"].y) / 4;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIntersectArea(bbox1, bbox2) { // objects, lots\n        var bbox1_key = Object.keys(bbox1)\n        var bbox2_key = Object.keys(bbox2)\n        var intersection = [];\n\n        for (let i = 0; i < bbox1_key.length - 1; i++) {\n            for (let j = 0; j < bbox2_key.length - 1; j++) {\n                var A1 = bbox1[bbox1_key[i + 1]].y - bbox1[bbox1_key[i]].y; // Ax + By + C = 0\n                var B1 = bbox1[bbox1_key[i]].x - bbox1[bbox1_key[i + 1]].x;\n                var C1 = - A1 * bbox1[bbox1_key[i]].x - B1 * bbox1[bbox1_key[i]].y;\n\n                var A2 = bbox2[bbox2_key[j + 1]].y - bbox2[bbox2_key[j]].y;\n                var B2 = bbox2[bbox2_key[j]].x - bbox2[bbox2_key[j + 1]].x;\n                var C2 = - A2 * bbox2[bbox2_key[j]].x - B2 * bbox2[bbox2_key[j]].y;\n\n                // parallel lines case\n                if (A1 * B2 == A2 * B1) {\n                    // coincide case\n                    if ((A1 * C2 == A2 * C1) && (B1 * C2 == B2 * C1)) {\n                        if (B1 == 0 && A1 == 0) { // one point bbox case\n                            intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B2 == 0 && A2 == 0) { // one point bbox case\n                            intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B1 == 0) { // vertical lines case\n                            var y_min1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i]].y : bbox1[bbox1_key[i + 1]].y;\n                            var y_max1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i + 1]].y : bbox1[bbox1_key[i]].y;\n                            var y_min2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i]].y : bbox2[bbox2_key[i + 1]].y;\n                            var y_max2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i + 1]].y : bbox2[bbox2_key[i]].y;\n                            if ((y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var y_min = (y_min1 < y_min2) ? y_min2 : y_min1;\n                                var y_max = (y_max1 < y_max2) ? y_max1 : y_max2;\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_min.toFixed(6)]);\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_max.toFixed(6)]);\n                            }\n                        }\n                        else if (A1 == 0) { // horizontal lines case\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                intersection.push([x_min.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                            }\n                        }\n                        else {\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1) && (y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                var xY_min = (-A1 * x_min - C1) / B1\n                                var xY_max = (-A1 * x_max - C1) / B1\n                                intersection.push([x_min.toFixed(6), xY_min.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), xY_max.toFixed(6)]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // get intersection coordinates\n                    var x1 = bbox1[bbox1_key[i]].x;\n                    var x2 = bbox1[bbox1_key[i + 1]].x;\n                    var x3 = bbox2[bbox2_key[j]].x;\n                    var x4 = bbox2[bbox2_key[j + 1]].x;\n                    var y1 = bbox1[bbox1_key[i]].y;\n                    var y2 = bbox1[bbox1_key[i + 1]].y;\n                    var y3 = bbox2[bbox2_key[j]].y;\n                    var y4 = bbox2[bbox2_key[j + 1]].y;\n\n                    var den = (x2 - x1) * (y3 - y4) - (y2 - y1) * (x3 - x4);\n                    var t = ((x3 - x1) * (y3 - y4) - (y3 - y1) * (x3 - x4)) / den;\n                    var u = ((x3 - x1) * (y1 - y2) - (y3 - y1) * (x1 - x2)) / den;\n                    if ((t >= 0) && (t <= 1) && (u >= 0) && (u <= 1)) { // intersect happens if this condition is fulfilled\n                        var ix = x1 + t * (x2 - x1);\n                        var iy = y1 + t * (y2 - y1);\n                        intersection.push([ix.toFixed(6), iy.toFixed(6)]);\n                    }\n                }\n            }\n        }\n        // get clipped coordinates\n        var specialcase1 = true;\n        var specialcase2 = false;\n        var temp1 = bbox1[bbox1_key[0]];\n        var temp2 = bbox2[bbox2_key[0]];\n        for (let i = 1; i < bbox1_key.length - 1; i++) { // special case\n            if (temp1 !== bbox1[bbox1_key[i]]) {\n                specialcase1 = false;\n                break;\n            }\n        }\n        for (let i = 1; i < bbox2_key.length - 1; i++) {\n            if (temp2 !== bbox2[bbox2_key[i]]) {\n                specialcase2 = false;\n                break;\n            }\n        }\n        if (!(specialcase2)) {\n            for (let i = 0; i < bbox1_key.length - 1; i++) {\n                var sign_check = [];\n                for (let j = 0; j < bbox2_key.length - 1; j++) {\n                    var x1 = bbox2[bbox2_key[j]].x\n                    var x2 = bbox2[bbox2_key[j + 1]].x\n                    var y1 = bbox2[bbox2_key[j]].y\n                    var y2 = bbox2[bbox2_key[j + 1]].y\n                    var cross_prod = (bbox1[bbox1_key[i]].x - x1) * (y2 - y1) - (bbox1[bbox1_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) { // similar signs indicate the coordinate is within another bbox\n                    intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox1[bbox1_key[i]].x, bbox1[bbox1_key[i]].y]);\n                }\n            }\n        }\n        if (!(specialcase1)) {\n            for (let i = 0; i < bbox2_key.length - 1; i++) { // similar purpose but for second bbox\n                var sign_check = [];\n                for (let j = 0; j < bbox1_key.length - 1; j++) {\n                    var x1 = bbox1[bbox1_key[j]].x\n                    var x2 = bbox1[bbox1_key[j + 1]].x\n                    var y1 = bbox1[bbox1_key[j]].y\n                    var y2 = bbox1[bbox1_key[j + 1]].y\n                    var cross_prod = (bbox2[bbox2_key[i]].x - x1) * (y2 - y1) - (bbox2[bbox2_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) {\n                    intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox2[bbox2_key[i]].x, bbox2[bbox2_key[i]].y]);\n                }\n            }\n        }\n        intersection = intersection.filter((item, index, self) =>\n            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(item))\n        );\n        // sort intersection points\n        if (intersection.length > 2) {\n            var intersection_angle = [];\n            var intersection_distance = [];\n\n            let minIndex = intersection.reduce((minIdx, currentValue, currentIndex, array) => {\n                if (currentValue[0] < array[minIdx][0]) {\n                    return currentIndex;\n                } else if (currentValue[0] === array[minIdx][0]) {\n                    return currentValue[1] < array[minIdx][1] ? currentIndex : minIdx;\n                } else {\n                    return minIdx;\n                }\n            }, 0);\n            var temp_intersection = intersection.filter((_, index) => index !== minIndex);\n            for (let i = 0; i < temp_intersection.length; i++) {\n                intersection_angle.push(Math.atan2(temp_intersection[i][1] - intersection[minIndex][1], temp_intersection[i][0] - intersection[minIndex][0]));\n                intersection_distance.push((temp_intersection[i][1] - intersection[minIndex][1]) ** 2 + (temp_intersection[i][0] - intersection[minIndex][0]) ** 2);\n            }\n            let combined = temp_intersection.map((point, index) => ({ // sort intersect coordinates based on angle and then distance\n                point: point,\n                angle: intersection_angle[index],\n                distance: intersection_distance[index]\n            }));\n            combined.sort((a, b) => a.angle - b.angle || a.distance - b.distance);\n            let sorted_intersection = combined.map(item => item.point);\n            sorted_intersection.unshift(intersection[minIndex]);\n            sorted_intersection.push(intersection[minIndex]);\n            // shoelace algorithm to calculate the intersect area\n            var area = 0;\n            for (let i = 0; i < sorted_intersection.length - 1; i++) {\n                area += ((sorted_intersection[i][0] * sorted_intersection[i + 1][1])\n                    - (sorted_intersection[i + 1][0] * sorted_intersection[i][1]))\n            }\n            return area;\n        }\n        return 0;\n    }\n    function calculateIOU(bbox1, bbox2, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area1 = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n\n            var lot_area2 = (bbox2[\"vertex1\"].x * bbox2[\"vertex2\"].y) + (bbox2[\"vertex2\"].x * bbox2[\"vertex3\"].y)\n                + (bbox2[\"vertex3\"].x * bbox2[\"vertex4\"].y) + (bbox2[\"vertex4\"].x * bbox2[\"vertex_0\"].y)\n                - ((bbox2[\"vertex2\"].x * bbox2[\"vertex1\"].y) + (bbox2[\"vertex3\"].x * bbox2[\"vertex2\"].y)\n                    + (bbox2[\"vertex4\"].x * bbox2[\"vertex3\"].y) + (bbox2[\"vertex_0\"].x * bbox2[\"vertex4\"].y));\n            return intersectArea / (lot_area1 + lot_area2 - intersectArea)\n        }\n        return 0;\n    }\n    function calculateIOR(bbox1, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n            return intersectArea / lot_area;\n        }\n        return 0;\n    }\n\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({ \"occupied\": 0 });\n        }\n    }\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) { // find all lots within the object centroid distance threshold\n            var objectCentroid = getBboxCentroid(payload[\"objects\"][key1]);\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getBboxCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // calculate IOU or IOR\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        var IOR = 0;\n                        if (intersection_type == \"region\") {\n                            IOR = calculateIOR(payload[\"lots\"][i], intersectRegion)\n                        }\n                        else if (intersection_type == \"object\") {\n                            IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                        }\n                        if (IOR > intersection_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            else { // consider the best lot only\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    var IOR = 0;\n                    if (intersection_type == \"region\") {\n                        IOR = calculateIOR(payload[\"lots\"][best_region_index], intersectRegion)\n                    }\n                    else if (intersection_type == \"object\") {\n                        IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                    }\n                    if (IOR > intersection_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied;\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        results = initializeResults(results, occupied, i);\n        previous_data = initializePreviousData(results, i);\n        if (results[\"Region \" + (i + 1)].hasOwnProperty(\"id\") || previous_data[\"Region \" + (i + 1)].hasOwnProperty(\"id\")) {\n            results = handleObjectWithID(results, i);\n        }\n        else if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            results = handleOccupiedRegion(results, i);\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results = handleNotOccupiedRegion(results, i);\n        }\n    }\n    return results;\n}\n\nfunction initializeResults(results, occupied, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    if (!results[regionKey]) {\n        results[regionKey] = {};\n    }\n    results[regionKey][\"video_id\"] = video_id;\n    results[regionKey][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n    if (occupied[i].hasOwnProperty(\"occupied\")) {\n        results[regionKey][\"occupied\"] = occupied[i].occupied;\n    }\n\n    if (occupied[i].hasOwnProperty(\"extra\")) {\n        for (let key in occupied[i].extra) {\n            results[regionKey][key] = occupied[i].extra[key];\n        }\n    }\n    if (results[regionKey].hasOwnProperty(\"id\") || (previous_data && previous_data.hasOwnProperty(regionKey) && previous_data[regionKey].hasOwnProperty(\"id\"))) {\n        results[regionKey][\"actual_entry_time\"] = [];\n        results[regionKey][\"actual_dwell_time\"] = [];\n        results[regionKey][\"entry_time\"] = [];\n        results[regionKey][\"dwell_time\"] = [];\n        results[regionKey][\"exit_time\"] = [];\n    }\n    else {\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"actual_dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"exit_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n    }\n    return results;\n}\n\nfunction initializePreviousData(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    // Ensure previous_data is set up for this region.\n    if (!previous_data) {\n        previous_data = {};\n    }\n    if (results[regionKey].hasOwnProperty(\"id\")) {\n        if (!previous_data[regionKey]) {\n            previous_data[regionKey] = {};\n            previous_data[regionKey][\"id\"] = [];\n            previous_data[regionKey][\"actual_entry_time\"] = [];\n            previous_data[regionKey][\"actual_dwell_time\"] = [];\n            previous_data[regionKey][\"entry_time\"] = [];\n            previous_data[regionKey][\"dwell_time\"] = [];\n            previous_data[regionKey][\"exit_time\"] = [];\n        }\n    }\n    else {\n        if (!previous_data.hasOwnProperty(regionKey)) {\n            previous_data[regionKey] = results[regionKey];\n            previous_data[regionKey][\"actual_entry_time\"] = \"\";\n            previous_data[regionKey][\"actual_dwell_time\"] = \"\";\n            previous_data[regionKey][\"entry_time\"] = \"\";\n            previous_data[regionKey][\"dwell_time\"] = \"\";\n            previous_data[regionKey][\"exit_time\"] = \"\";\n            previous_data[regionKey][\"occupancy_check\"] = 0;\n        }\n    }\n\n    return previous_data;\n}\n\nfunction handleObjectWithID(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    const resultIds = results[regionKey][\"id\"];\n    const previousDataIds = previous_data[regionKey][\"id\"];\n\n    if (!resultIds && !previousDataIds) {\n        return results;\n    }\n\n    if (resultIds) {\n        for (let j = 0; j < resultIds.length; j++) {\n            // Check existing id data\n            let prevIndex = -1;\n\n            if (previous_data[regionKey][\"id\"] && previous_data[regionKey][\"id\"].length > 0) {\n                prevIndex = previous_data[regionKey][\"id\"].indexOf(resultIds[j]);\n            }\n\n            if (prevIndex === -1) {\n                results[regionKey][\"actual_entry_time\"].push(msg.nodered_timestamp);\n                results[regionKey][\"entry_time\"].push(msg.object_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(\"00:00:00\");\n                results[regionKey][\"dwell_time\"].push(0);\n                results[regionKey][\"exit_time\"].push(\"\");\n            } else {\n                results[regionKey][\"actual_entry_time\"].push(previous_data[regionKey][\"actual_entry_time\"][prevIndex]);\n                results[regionKey][\"entry_time\"].push(previous_data[regionKey][\"entry_time\"][prevIndex]);\n\n                // Calculate dwell time.\n                const dwell_timestamp = (msg.object_timestamp - results[regionKey][\"entry_time\"][j]);\n                const dwell_hours = Math.floor(dwell_timestamp / 3600).toString().padStart(2, \"0\");\n                const dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n                const dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n                results[regionKey][\"dwell_time\"].push(dwell_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds);\n                results[regionKey][\"exit_time\"].push(\"\");\n            }\n        }\n    }\n\n    if (previousDataIds) {\n        for (let j = 0; j < previousDataIds.length; j++) {\n            let prevIndex = -1;\n\n            if (!results[regionKey][\"id\"]) {\n                results[regionKey] = previous_data[regionKey];\n                results[regionKey][\"occupied\"] = 0;\n                break;\n            }\n            else {\n                if (!results[regionKey][\"dwell_time\"].some(val => val >= stop_duration)) {\n                    results[regionKey][\"occupied\"] = 0;\n                }\n\n                prevIndex = results[regionKey][\"id\"].indexOf(previousDataIds[j]);\n                if (prevIndex === -1) {\n                    let keyList = Object.keys(previous_data[regionKey]);\n                    for (let k = 0; k < keyList.length; k++) {\n                        if (keyList[k] == \"video_id\" || keyList[k] == \"region_id\" || keyList[k] == \"occupied\") {\n                            continue;\n                        }\n                        results[regionKey][keyList[k]].push(previous_data[regionKey][keyList[k]][j]);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction handleOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    if (previous_data[regionKey][\"entry_time\"] == \"\") {\n        results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n        results[regionKey][\"entry_time\"] = msg.object_timestamp;\n    }\n    else {\n        if (previous_data[regionKey][\"occupancy_check\"] >= occupancy_check_duration) {\n            results[regionKey][\"actual_dwell_time\"] = \"00:00:00\";\n            results[regionKey][\"dwell_time\"] = 0;\n            results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n            results[regionKey][\"entry_time\"] = msg.object_timestamp;\n        }\n        else {\n            results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n            results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n        }\n\n        var dwell_timestamp = msg.object_timestamp - results[regionKey][\"entry_time\"];\n        var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n        dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, \"0\") : dwell_hours.toString();\n        var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n        var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n\n        results[regionKey][\"dwell_time\"] = dwell_timestamp;\n        results[regionKey][\"actual_dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n        results[regionKey][\"occupancy_check\"] = 0;\n    }\n\n    return results;\n}\n\nfunction handleNotOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n    results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n    results[regionKey][\"actual_dwell_time\"] = previous_data[regionKey][\"actual_dwell_time\"];\n    results[regionKey][\"dwell_time\"] = previous_data[regionKey][\"dwell_time\"];\n    results[regionKey][\"occupancy_check\"] = previous_data[regionKey][\"occupancy_check\"] + 1;\n\n    if (previous_data[regionKey][\"exit_time\"]) {\n        results[regionKey][\"exit_time\"] = previous_data[regionKey][\"exit_time\"];\n    }\n    else {\n        results[regionKey][\"exit_time\"] = msg.nodered_timestamp;\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, intersection_type, intersection_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get(\"distance_threshold\");\nvar intersection_type = flow.get(\"intersection_type\");\nvar intersection_threshold = flow.get(\"intersection_threshold\");\nvar object_counter = flow.get(\"object_counter\");\n\nmsg.payload = main(payload, distance_threshold, intersection_type, intersection_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 820,
        "wires": [
            [
                "2d953ea2b9cb5170",
                "deb240b2b63ec5ac"
            ]
        ]
    },
    {
        "id": "4e43313da371d101",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 3",
        "func": "let region_name = 'predefined_regions_3';\nlet detection_name = 'object_detection_3';\nlet previous_data_name = 'previous_data_3';\nlet occupancy_check_duration = 60;\nlet video_id = 3;\nlet region_id = 1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\nvar stop_duration = flow.get(\"stop_duration\");\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty(\"type\")) {\n            current_object_data[\"type\"] = object_data[\"type\"];\n        }\n        if (object_data.hasOwnProperty(\"color\")) {\n            current_object_data[\"color\"] = object_data[\"color\"];\n        }\n        if (object_data.hasOwnProperty(\"license_plate\")) {\n            current_object_data[\"license_plate\"] = object_data[\"license_plate\"];\n        }\n        if (object_data.hasOwnProperty(\"id\")) {\n            current_object_data[\"id\"] = object_data[\"id\"];\n        }\n        if (object_data.hasOwnProperty(\"roi_type\")) {\n            current_object_data[\"roi_type\"] = object_data[\"roi_type\"];\n        }\n        return current_object_data;\n    }\n    function getLotBbox(lot_data) {\n        return { \"vertex1\": lot_data.vertex1, \"vertex2\": lot_data.vertex2, \"vertex3\": lot_data.vertex3, \"vertex4\": lot_data.vertex4, \"vertex_0\": lot_data.vertex1 };\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var objectData = getObjectData(payload[key]);\n            if (objectData !== null) {\n                objects_extra.push(\n                    objectData\n                );\n                objects.push(\n                    payload[key][\"bbox\"]\n                );\n            }\n        }\n    }\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    function getBboxCentroid(bbox) {\n        var centroid_x = (bbox[\"vertex1\"].x + bbox[\"vertex2\"].x + bbox[\"vertex3\"].x + bbox[\"vertex4\"].x) / 4;\n        var centroid_y = (bbox[\"vertex1\"].y + bbox[\"vertex2\"].y + bbox[\"vertex3\"].y + bbox[\"vertex4\"].y) / 4;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIntersectArea(bbox1, bbox2) { // objects, lots\n        var bbox1_key = Object.keys(bbox1)\n        var bbox2_key = Object.keys(bbox2)\n        var intersection = [];\n\n        for (let i = 0; i < bbox1_key.length - 1; i++) {\n            for (let j = 0; j < bbox2_key.length - 1; j++) {\n                var A1 = bbox1[bbox1_key[i + 1]].y - bbox1[bbox1_key[i]].y; // Ax + By + C = 0\n                var B1 = bbox1[bbox1_key[i]].x - bbox1[bbox1_key[i + 1]].x;\n                var C1 = - A1 * bbox1[bbox1_key[i]].x - B1 * bbox1[bbox1_key[i]].y;\n\n                var A2 = bbox2[bbox2_key[j + 1]].y - bbox2[bbox2_key[j]].y;\n                var B2 = bbox2[bbox2_key[j]].x - bbox2[bbox2_key[j + 1]].x;\n                var C2 = - A2 * bbox2[bbox2_key[j]].x - B2 * bbox2[bbox2_key[j]].y;\n\n                // parallel lines case\n                if (A1 * B2 == A2 * B1) {\n                    // coincide case\n                    if ((A1 * C2 == A2 * C1) && (B1 * C2 == B2 * C1)) {\n                        if (B1 == 0 && A1 == 0) { // one point bbox case\n                            intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B2 == 0 && A2 == 0) { // one point bbox case\n                            intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B1 == 0) { // vertical lines case\n                            var y_min1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i]].y : bbox1[bbox1_key[i + 1]].y;\n                            var y_max1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i + 1]].y : bbox1[bbox1_key[i]].y;\n                            var y_min2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i]].y : bbox2[bbox2_key[i + 1]].y;\n                            var y_max2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i + 1]].y : bbox2[bbox2_key[i]].y;\n                            if ((y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var y_min = (y_min1 < y_min2) ? y_min2 : y_min1;\n                                var y_max = (y_max1 < y_max2) ? y_max1 : y_max2;\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_min.toFixed(6)]);\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_max.toFixed(6)]);\n                            }\n                        }\n                        else if (A1 == 0) { // horizontal lines case\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                intersection.push([x_min.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                            }\n                        }\n                        else {\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1) && (y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                var xY_min = (-A1 * x_min - C1) / B1\n                                var xY_max = (-A1 * x_max - C1) / B1\n                                intersection.push([x_min.toFixed(6), xY_min.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), xY_max.toFixed(6)]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // get intersection coordinates\n                    var x1 = bbox1[bbox1_key[i]].x;\n                    var x2 = bbox1[bbox1_key[i + 1]].x;\n                    var x3 = bbox2[bbox2_key[j]].x;\n                    var x4 = bbox2[bbox2_key[j + 1]].x;\n                    var y1 = bbox1[bbox1_key[i]].y;\n                    var y2 = bbox1[bbox1_key[i + 1]].y;\n                    var y3 = bbox2[bbox2_key[j]].y;\n                    var y4 = bbox2[bbox2_key[j + 1]].y;\n\n                    var den = (x2 - x1) * (y3 - y4) - (y2 - y1) * (x3 - x4);\n                    var t = ((x3 - x1) * (y3 - y4) - (y3 - y1) * (x3 - x4)) / den;\n                    var u = ((x3 - x1) * (y1 - y2) - (y3 - y1) * (x1 - x2)) / den;\n                    if ((t >= 0) && (t <= 1) && (u >= 0) && (u <= 1)) { // intersect happens if this condition is fulfilled\n                        var ix = x1 + t * (x2 - x1);\n                        var iy = y1 + t * (y2 - y1);\n                        intersection.push([ix.toFixed(6), iy.toFixed(6)]);\n                    }\n                }\n            }\n        }\n        // get clipped coordinates\n        var specialcase1 = true;\n        var specialcase2 = false;\n        var temp1 = bbox1[bbox1_key[0]];\n        var temp2 = bbox2[bbox2_key[0]];\n        for (let i = 1; i < bbox1_key.length - 1; i++) { // special case\n            if (temp1 !== bbox1[bbox1_key[i]]) {\n                specialcase1 = false;\n                break;\n            }\n        }\n        for (let i = 1; i < bbox2_key.length - 1; i++) {\n            if (temp2 !== bbox2[bbox2_key[i]]) {\n                specialcase2 = false;\n                break;\n            }\n        }\n        if (!(specialcase2)) {\n            for (let i = 0; i < bbox1_key.length - 1; i++) {\n                var sign_check = [];\n                for (let j = 0; j < bbox2_key.length - 1; j++) {\n                    var x1 = bbox2[bbox2_key[j]].x\n                    var x2 = bbox2[bbox2_key[j + 1]].x\n                    var y1 = bbox2[bbox2_key[j]].y\n                    var y2 = bbox2[bbox2_key[j + 1]].y\n                    var cross_prod = (bbox1[bbox1_key[i]].x - x1) * (y2 - y1) - (bbox1[bbox1_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) { // similar signs indicate the coordinate is within another bbox\n                    intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox1[bbox1_key[i]].x, bbox1[bbox1_key[i]].y]);\n                }\n            }\n        }\n        if (!(specialcase1)) {\n            for (let i = 0; i < bbox2_key.length - 1; i++) { // similar purpose but for second bbox\n                var sign_check = [];\n                for (let j = 0; j < bbox1_key.length - 1; j++) {\n                    var x1 = bbox1[bbox1_key[j]].x\n                    var x2 = bbox1[bbox1_key[j + 1]].x\n                    var y1 = bbox1[bbox1_key[j]].y\n                    var y2 = bbox1[bbox1_key[j + 1]].y\n                    var cross_prod = (bbox2[bbox2_key[i]].x - x1) * (y2 - y1) - (bbox2[bbox2_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) {\n                    intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox2[bbox2_key[i]].x, bbox2[bbox2_key[i]].y]);\n                }\n            }\n        }\n        intersection = intersection.filter((item, index, self) =>\n            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(item))\n        );\n        // sort intersection points\n        if (intersection.length > 2) {\n            var intersection_angle = [];\n            var intersection_distance = [];\n\n            let minIndex = intersection.reduce((minIdx, currentValue, currentIndex, array) => {\n                if (currentValue[0] < array[minIdx][0]) {\n                    return currentIndex;\n                } else if (currentValue[0] === array[minIdx][0]) {\n                    return currentValue[1] < array[minIdx][1] ? currentIndex : minIdx;\n                } else {\n                    return minIdx;\n                }\n            }, 0);\n            var temp_intersection = intersection.filter((_, index) => index !== minIndex);\n            for (let i = 0; i < temp_intersection.length; i++) {\n                intersection_angle.push(Math.atan2(temp_intersection[i][1] - intersection[minIndex][1], temp_intersection[i][0] - intersection[minIndex][0]));\n                intersection_distance.push((temp_intersection[i][1] - intersection[minIndex][1]) ** 2 + (temp_intersection[i][0] - intersection[minIndex][0]) ** 2);\n            }\n            let combined = temp_intersection.map((point, index) => ({ // sort intersect coordinates based on angle and then distance\n                point: point,\n                angle: intersection_angle[index],\n                distance: intersection_distance[index]\n            }));\n            combined.sort((a, b) => a.angle - b.angle || a.distance - b.distance);\n            let sorted_intersection = combined.map(item => item.point);\n            sorted_intersection.unshift(intersection[minIndex]);\n            sorted_intersection.push(intersection[minIndex]);\n            // shoelace algorithm to calculate the intersect area\n            var area = 0;\n            for (let i = 0; i < sorted_intersection.length - 1; i++) {\n                area += ((sorted_intersection[i][0] * sorted_intersection[i + 1][1])\n                    - (sorted_intersection[i + 1][0] * sorted_intersection[i][1]))\n            }\n            return area;\n        }\n        return 0;\n    }\n    function calculateIOU(bbox1, bbox2, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area1 = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n\n            var lot_area2 = (bbox2[\"vertex1\"].x * bbox2[\"vertex2\"].y) + (bbox2[\"vertex2\"].x * bbox2[\"vertex3\"].y)\n                + (bbox2[\"vertex3\"].x * bbox2[\"vertex4\"].y) + (bbox2[\"vertex4\"].x * bbox2[\"vertex_0\"].y)\n                - ((bbox2[\"vertex2\"].x * bbox2[\"vertex1\"].y) + (bbox2[\"vertex3\"].x * bbox2[\"vertex2\"].y)\n                    + (bbox2[\"vertex4\"].x * bbox2[\"vertex3\"].y) + (bbox2[\"vertex_0\"].x * bbox2[\"vertex4\"].y));\n            return intersectArea / (lot_area1 + lot_area2 - intersectArea)\n        }\n        return 0;\n    }\n    function calculateIOR(bbox1, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n            return intersectArea / lot_area;\n        }\n        return 0;\n    }\n\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({ \"occupied\": 0 });\n        }\n    }\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) { // find all lots within the object centroid distance threshold\n            var objectCentroid = getBboxCentroid(payload[\"objects\"][key1]);\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getBboxCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // calculate IOU or IOR\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        var IOR = 0;\n                        if (intersection_type == \"region\") {\n                            IOR = calculateIOR(payload[\"lots\"][i], intersectRegion)\n                        }\n                        else if (intersection_type == \"object\") {\n                            IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                        }\n                        if (IOR > intersection_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            else { // consider the best lot only\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    var IOR = 0;\n                    if (intersection_type == \"region\") {\n                        IOR = calculateIOR(payload[\"lots\"][best_region_index], intersectRegion)\n                    }\n                    else if (intersection_type == \"object\") {\n                        IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                    }\n                    if (IOR > intersection_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied;\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        results = initializeResults(results, occupied, i);\n        previous_data = initializePreviousData(results, i);\n        if (results[\"Region \" + (i + 1)].hasOwnProperty(\"id\") || previous_data[\"Region \" + (i + 1)].hasOwnProperty(\"id\")) {\n            results = handleObjectWithID(results, i);\n        }\n        else if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            results = handleOccupiedRegion(results, i);\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results = handleNotOccupiedRegion(results, i);\n        }\n    }\n    return results;\n}\n\nfunction initializeResults(results, occupied, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    if (!results[regionKey]) {\n        results[regionKey] = {};\n    }\n    results[regionKey][\"video_id\"] = video_id;\n    results[regionKey][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n    if (occupied[i].hasOwnProperty(\"occupied\")) {\n        results[regionKey][\"occupied\"] = occupied[i].occupied;\n    }\n\n    if (occupied[i].hasOwnProperty(\"extra\")) {\n        for (let key in occupied[i].extra) {\n            results[regionKey][key] = occupied[i].extra[key];\n        }\n    }\n    if (results[regionKey].hasOwnProperty(\"id\") || (previous_data && previous_data.hasOwnProperty(regionKey) && previous_data[regionKey].hasOwnProperty(\"id\"))) {\n        results[regionKey][\"actual_entry_time\"] = [];\n        results[regionKey][\"actual_dwell_time\"] = [];\n        results[regionKey][\"entry_time\"] = [];\n        results[regionKey][\"dwell_time\"] = [];\n        results[regionKey][\"exit_time\"] = [];\n    }\n    else {\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"actual_dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"exit_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n    }\n    return results;\n}\n\nfunction initializePreviousData(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    // Ensure previous_data is set up for this region.\n    if (!previous_data) {\n        previous_data = {};\n    }\n    if (results[regionKey].hasOwnProperty(\"id\")) {\n        if (!previous_data[regionKey]) {\n            previous_data[regionKey] = {};\n            previous_data[regionKey][\"id\"] = [];\n            previous_data[regionKey][\"actual_entry_time\"] = [];\n            previous_data[regionKey][\"actual_dwell_time\"] = [];\n            previous_data[regionKey][\"entry_time\"] = [];\n            previous_data[regionKey][\"dwell_time\"] = [];\n            previous_data[regionKey][\"exit_time\"] = [];\n        }\n    }\n    else {\n        if (!previous_data.hasOwnProperty(regionKey)) {\n            previous_data[regionKey] = results[regionKey];\n            previous_data[regionKey][\"actual_entry_time\"] = \"\";\n            previous_data[regionKey][\"actual_dwell_time\"] = \"\";\n            previous_data[regionKey][\"entry_time\"] = \"\";\n            previous_data[regionKey][\"dwell_time\"] = \"\";\n            previous_data[regionKey][\"exit_time\"] = \"\";\n            previous_data[regionKey][\"occupancy_check\"] = 0;\n        }\n    }\n\n    return previous_data;\n}\n\nfunction handleObjectWithID(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    const resultIds = results[regionKey][\"id\"];\n    const previousDataIds = previous_data[regionKey][\"id\"];\n\n    if (!resultIds && !previousDataIds) {\n        return results;\n    }\n\n    if (resultIds) {\n        for (let j = 0; j < resultIds.length; j++) {\n            // Check existing id data\n            let prevIndex = -1;\n\n            if (previous_data[regionKey][\"id\"] && previous_data[regionKey][\"id\"].length > 0) {\n                prevIndex = previous_data[regionKey][\"id\"].indexOf(resultIds[j]);\n            }\n\n            if (prevIndex === -1) {\n                results[regionKey][\"actual_entry_time\"].push(msg.nodered_timestamp);\n                results[regionKey][\"entry_time\"].push(msg.object_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(\"00:00:00\");\n                results[regionKey][\"dwell_time\"].push(0);\n                results[regionKey][\"exit_time\"].push(\"\");\n            } else {\n                results[regionKey][\"actual_entry_time\"].push(previous_data[regionKey][\"actual_entry_time\"][prevIndex]);\n                results[regionKey][\"entry_time\"].push(previous_data[regionKey][\"entry_time\"][prevIndex]);\n\n                // Calculate dwell time.\n                const dwell_timestamp = (msg.object_timestamp - results[regionKey][\"entry_time\"][j]);\n                const dwell_hours = Math.floor(dwell_timestamp / 3600).toString().padStart(2, \"0\");\n                const dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n                const dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n                results[regionKey][\"dwell_time\"].push(dwell_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds);\n                results[regionKey][\"exit_time\"].push(\"\");\n            }\n        }\n    }\n\n    if (previousDataIds) {\n        for (let j = 0; j < previousDataIds.length; j++) {\n            let prevIndex = -1;\n\n            if (!results[regionKey][\"id\"]) {\n                results[regionKey] = previous_data[regionKey];\n                results[regionKey][\"occupied\"] = 0;\n                break;\n            }\n            else {\n                if (!results[regionKey][\"dwell_time\"].some(val => val >= stop_duration)) {\n                    results[regionKey][\"occupied\"] = 0;\n                }\n\n                prevIndex = results[regionKey][\"id\"].indexOf(previousDataIds[j]);\n                if (prevIndex === -1) {\n                    let keyList = Object.keys(previous_data[regionKey]);\n                    for (let k = 0; k < keyList.length; k++) {\n                        if (keyList[k] == \"video_id\" || keyList[k] == \"region_id\" || keyList[k] == \"occupied\") {\n                            continue;\n                        }\n                        results[regionKey][keyList[k]].push(previous_data[regionKey][keyList[k]][j]);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction handleOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    if (previous_data[regionKey][\"entry_time\"] == \"\") {\n        results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n        results[regionKey][\"entry_time\"] = msg.object_timestamp;\n    }\n    else {\n        if (previous_data[regionKey][\"occupancy_check\"] >= occupancy_check_duration) {\n            results[regionKey][\"actual_dwell_time\"] = \"00:00:00\";\n            results[regionKey][\"dwell_time\"] = 0;\n            results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n            results[regionKey][\"entry_time\"] = msg.object_timestamp;\n        }\n        else {\n            results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n            results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n        }\n\n        var dwell_timestamp = msg.object_timestamp - results[regionKey][\"entry_time\"];\n        var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n        dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, \"0\") : dwell_hours.toString();\n        var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n        var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n\n        results[regionKey][\"dwell_time\"] = dwell_timestamp;\n        results[regionKey][\"actual_dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n        results[regionKey][\"occupancy_check\"] = 0;\n    }\n\n    return results;\n}\n\nfunction handleNotOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n    results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n    results[regionKey][\"actual_dwell_time\"] = previous_data[regionKey][\"actual_dwell_time\"];\n    results[regionKey][\"dwell_time\"] = previous_data[regionKey][\"dwell_time\"];\n    results[regionKey][\"occupancy_check\"] = previous_data[regionKey][\"occupancy_check\"] + 1;\n\n    if (previous_data[regionKey][\"exit_time\"]) {\n        results[regionKey][\"exit_time\"] = previous_data[regionKey][\"exit_time\"];\n    }\n    else {\n        results[regionKey][\"exit_time\"] = msg.nodered_timestamp;\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, intersection_type, intersection_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get(\"distance_threshold\");\nvar intersection_type = flow.get(\"intersection_type\");\nvar intersection_threshold = flow.get(\"intersection_threshold\");\nvar object_counter = flow.get(\"object_counter\");\n\nmsg.payload = main(payload, distance_threshold, intersection_type, intersection_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 900,
        "wires": [
            [
                "62da09d3589a3293",
                "deb240b2b63ec5ac"
            ]
        ]
    },
    {
        "id": "c4a9ee507bb7935f",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 4",
        "func": "let region_name = 'predefined_regions_4';\nlet detection_name = 'object_detection_4';\nlet previous_data_name = 'previous_data_4';\nlet occupancy_check_duration = 60;\nlet video_id = 4;\nlet region_id = 1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\nvar stop_duration = flow.get(\"stop_duration\");\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty(\"type\")) {\n            current_object_data[\"type\"] = object_data[\"type\"];\n        }\n        if (object_data.hasOwnProperty(\"color\")) {\n            current_object_data[\"color\"] = object_data[\"color\"];\n        }\n        if (object_data.hasOwnProperty(\"license_plate\")) {\n            current_object_data[\"license_plate\"] = object_data[\"license_plate\"];\n        }\n        if (object_data.hasOwnProperty(\"id\")) {\n            current_object_data[\"id\"] = object_data[\"id\"];\n        }\n        if (object_data.hasOwnProperty(\"roi_type\")) {\n            current_object_data[\"roi_type\"] = object_data[\"roi_type\"];\n        }\n        return current_object_data;\n    }\n    function getLotBbox(lot_data) {\n        return { \"vertex1\": lot_data.vertex1, \"vertex2\": lot_data.vertex2, \"vertex3\": lot_data.vertex3, \"vertex4\": lot_data.vertex4, \"vertex_0\": lot_data.vertex1 };\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var objectData = getObjectData(payload[key]);\n            if (objectData !== null) {\n                objects_extra.push(\n                    objectData\n                );\n                objects.push(\n                    payload[key][\"bbox\"]\n                );\n            }\n        }\n    }\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    function getBboxCentroid(bbox) {\n        var centroid_x = (bbox[\"vertex1\"].x + bbox[\"vertex2\"].x + bbox[\"vertex3\"].x + bbox[\"vertex4\"].x) / 4;\n        var centroid_y = (bbox[\"vertex1\"].y + bbox[\"vertex2\"].y + bbox[\"vertex3\"].y + bbox[\"vertex4\"].y) / 4;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIntersectArea(bbox1, bbox2) { // objects, lots\n        var bbox1_key = Object.keys(bbox1)\n        var bbox2_key = Object.keys(bbox2)\n        var intersection = [];\n\n        for (let i = 0; i < bbox1_key.length - 1; i++) {\n            for (let j = 0; j < bbox2_key.length - 1; j++) {\n                var A1 = bbox1[bbox1_key[i + 1]].y - bbox1[bbox1_key[i]].y; // Ax + By + C = 0\n                var B1 = bbox1[bbox1_key[i]].x - bbox1[bbox1_key[i + 1]].x;\n                var C1 = - A1 * bbox1[bbox1_key[i]].x - B1 * bbox1[bbox1_key[i]].y;\n\n                var A2 = bbox2[bbox2_key[j + 1]].y - bbox2[bbox2_key[j]].y;\n                var B2 = bbox2[bbox2_key[j]].x - bbox2[bbox2_key[j + 1]].x;\n                var C2 = - A2 * bbox2[bbox2_key[j]].x - B2 * bbox2[bbox2_key[j]].y;\n\n                // parallel lines case\n                if (A1 * B2 == A2 * B1) {\n                    // coincide case\n                    if ((A1 * C2 == A2 * C1) && (B1 * C2 == B2 * C1)) {\n                        if (B1 == 0 && A1 == 0) { // one point bbox case\n                            intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B2 == 0 && A2 == 0) { // one point bbox case\n                            intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B1 == 0) { // vertical lines case\n                            var y_min1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i]].y : bbox1[bbox1_key[i + 1]].y;\n                            var y_max1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i + 1]].y : bbox1[bbox1_key[i]].y;\n                            var y_min2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i]].y : bbox2[bbox2_key[i + 1]].y;\n                            var y_max2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i + 1]].y : bbox2[bbox2_key[i]].y;\n                            if ((y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var y_min = (y_min1 < y_min2) ? y_min2 : y_min1;\n                                var y_max = (y_max1 < y_max2) ? y_max1 : y_max2;\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_min.toFixed(6)]);\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_max.toFixed(6)]);\n                            }\n                        }\n                        else if (A1 == 0) { // horizontal lines case\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                intersection.push([x_min.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                            }\n                        }\n                        else {\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1) && (y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                var xY_min = (-A1 * x_min - C1) / B1\n                                var xY_max = (-A1 * x_max - C1) / B1\n                                intersection.push([x_min.toFixed(6), xY_min.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), xY_max.toFixed(6)]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // get intersection coordinates\n                    var x1 = bbox1[bbox1_key[i]].x;\n                    var x2 = bbox1[bbox1_key[i + 1]].x;\n                    var x3 = bbox2[bbox2_key[j]].x;\n                    var x4 = bbox2[bbox2_key[j + 1]].x;\n                    var y1 = bbox1[bbox1_key[i]].y;\n                    var y2 = bbox1[bbox1_key[i + 1]].y;\n                    var y3 = bbox2[bbox2_key[j]].y;\n                    var y4 = bbox2[bbox2_key[j + 1]].y;\n\n                    var den = (x2 - x1) * (y3 - y4) - (y2 - y1) * (x3 - x4);\n                    var t = ((x3 - x1) * (y3 - y4) - (y3 - y1) * (x3 - x4)) / den;\n                    var u = ((x3 - x1) * (y1 - y2) - (y3 - y1) * (x1 - x2)) / den;\n                    if ((t >= 0) && (t <= 1) && (u >= 0) && (u <= 1)) { // intersect happens if this condition is fulfilled\n                        var ix = x1 + t * (x2 - x1);\n                        var iy = y1 + t * (y2 - y1);\n                        intersection.push([ix.toFixed(6), iy.toFixed(6)]);\n                    }\n                }\n            }\n        }\n        // get clipped coordinates\n        var specialcase1 = true;\n        var specialcase2 = false;\n        var temp1 = bbox1[bbox1_key[0]];\n        var temp2 = bbox2[bbox2_key[0]];\n        for (let i = 1; i < bbox1_key.length - 1; i++) { // special case\n            if (temp1 !== bbox1[bbox1_key[i]]) {\n                specialcase1 = false;\n                break;\n            }\n        }\n        for (let i = 1; i < bbox2_key.length - 1; i++) {\n            if (temp2 !== bbox2[bbox2_key[i]]) {\n                specialcase2 = false;\n                break;\n            }\n        }\n        if (!(specialcase2)) {\n            for (let i = 0; i < bbox1_key.length - 1; i++) {\n                var sign_check = [];\n                for (let j = 0; j < bbox2_key.length - 1; j++) {\n                    var x1 = bbox2[bbox2_key[j]].x\n                    var x2 = bbox2[bbox2_key[j + 1]].x\n                    var y1 = bbox2[bbox2_key[j]].y\n                    var y2 = bbox2[bbox2_key[j + 1]].y\n                    var cross_prod = (bbox1[bbox1_key[i]].x - x1) * (y2 - y1) - (bbox1[bbox1_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) { // similar signs indicate the coordinate is within another bbox\n                    intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox1[bbox1_key[i]].x, bbox1[bbox1_key[i]].y]);\n                }\n            }\n        }\n        if (!(specialcase1)) {\n            for (let i = 0; i < bbox2_key.length - 1; i++) { // similar purpose but for second bbox\n                var sign_check = [];\n                for (let j = 0; j < bbox1_key.length - 1; j++) {\n                    var x1 = bbox1[bbox1_key[j]].x\n                    var x2 = bbox1[bbox1_key[j + 1]].x\n                    var y1 = bbox1[bbox1_key[j]].y\n                    var y2 = bbox1[bbox1_key[j + 1]].y\n                    var cross_prod = (bbox2[bbox2_key[i]].x - x1) * (y2 - y1) - (bbox2[bbox2_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) {\n                    intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox2[bbox2_key[i]].x, bbox2[bbox2_key[i]].y]);\n                }\n            }\n        }\n        intersection = intersection.filter((item, index, self) =>\n            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(item))\n        );\n        // sort intersection points\n        if (intersection.length > 2) {\n            var intersection_angle = [];\n            var intersection_distance = [];\n\n            let minIndex = intersection.reduce((minIdx, currentValue, currentIndex, array) => {\n                if (currentValue[0] < array[minIdx][0]) {\n                    return currentIndex;\n                } else if (currentValue[0] === array[minIdx][0]) {\n                    return currentValue[1] < array[minIdx][1] ? currentIndex : minIdx;\n                } else {\n                    return minIdx;\n                }\n            }, 0);\n            var temp_intersection = intersection.filter((_, index) => index !== minIndex);\n            for (let i = 0; i < temp_intersection.length; i++) {\n                intersection_angle.push(Math.atan2(temp_intersection[i][1] - intersection[minIndex][1], temp_intersection[i][0] - intersection[minIndex][0]));\n                intersection_distance.push((temp_intersection[i][1] - intersection[minIndex][1]) ** 2 + (temp_intersection[i][0] - intersection[minIndex][0]) ** 2);\n            }\n            let combined = temp_intersection.map((point, index) => ({ // sort intersect coordinates based on angle and then distance\n                point: point,\n                angle: intersection_angle[index],\n                distance: intersection_distance[index]\n            }));\n            combined.sort((a, b) => a.angle - b.angle || a.distance - b.distance);\n            let sorted_intersection = combined.map(item => item.point);\n            sorted_intersection.unshift(intersection[minIndex]);\n            sorted_intersection.push(intersection[minIndex]);\n            // shoelace algorithm to calculate the intersect area\n            var area = 0;\n            for (let i = 0; i < sorted_intersection.length - 1; i++) {\n                area += ((sorted_intersection[i][0] * sorted_intersection[i + 1][1])\n                    - (sorted_intersection[i + 1][0] * sorted_intersection[i][1]))\n            }\n            return area;\n        }\n        return 0;\n    }\n    function calculateIOU(bbox1, bbox2, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area1 = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n\n            var lot_area2 = (bbox2[\"vertex1\"].x * bbox2[\"vertex2\"].y) + (bbox2[\"vertex2\"].x * bbox2[\"vertex3\"].y)\n                + (bbox2[\"vertex3\"].x * bbox2[\"vertex4\"].y) + (bbox2[\"vertex4\"].x * bbox2[\"vertex_0\"].y)\n                - ((bbox2[\"vertex2\"].x * bbox2[\"vertex1\"].y) + (bbox2[\"vertex3\"].x * bbox2[\"vertex2\"].y)\n                    + (bbox2[\"vertex4\"].x * bbox2[\"vertex3\"].y) + (bbox2[\"vertex_0\"].x * bbox2[\"vertex4\"].y));\n            return intersectArea / (lot_area1 + lot_area2 - intersectArea)\n        }\n        return 0;\n    }\n    function calculateIOR(bbox1, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n            return intersectArea / lot_area;\n        }\n        return 0;\n    }\n\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({ \"occupied\": 0 });\n        }\n    }\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) { // find all lots within the object centroid distance threshold\n            var objectCentroid = getBboxCentroid(payload[\"objects\"][key1]);\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getBboxCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // calculate IOU or IOR\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        var IOR = 0;\n                        if (intersection_type == \"region\") {\n                            IOR = calculateIOR(payload[\"lots\"][i], intersectRegion)\n                        }\n                        else if (intersection_type == \"object\") {\n                            IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                        }\n                        if (IOR > intersection_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            else { // consider the best lot only\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    var IOR = 0;\n                    if (intersection_type == \"region\") {\n                        IOR = calculateIOR(payload[\"lots\"][best_region_index], intersectRegion)\n                    }\n                    else if (intersection_type == \"object\") {\n                        IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                    }\n                    if (IOR > intersection_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied;\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        results = initializeResults(results, occupied, i);\n        previous_data = initializePreviousData(results, i);\n        if (results[\"Region \" + (i + 1)].hasOwnProperty(\"id\") || previous_data[\"Region \" + (i + 1)].hasOwnProperty(\"id\")) {\n            results = handleObjectWithID(results, i);\n        }\n        else if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            results = handleOccupiedRegion(results, i);\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results = handleNotOccupiedRegion(results, i);\n        }\n    }\n    return results;\n}\n\nfunction initializeResults(results, occupied, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    if (!results[regionKey]) {\n        results[regionKey] = {};\n    }\n    results[regionKey][\"video_id\"] = video_id;\n    results[regionKey][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n    if (occupied[i].hasOwnProperty(\"occupied\")) {\n        results[regionKey][\"occupied\"] = occupied[i].occupied;\n    }\n\n    if (occupied[i].hasOwnProperty(\"extra\")) {\n        for (let key in occupied[i].extra) {\n            results[regionKey][key] = occupied[i].extra[key];\n        }\n    }\n    if (results[regionKey].hasOwnProperty(\"id\") || (previous_data && previous_data.hasOwnProperty(regionKey) && previous_data[regionKey].hasOwnProperty(\"id\"))) {\n        results[regionKey][\"actual_entry_time\"] = [];\n        results[regionKey][\"actual_dwell_time\"] = [];\n        results[regionKey][\"entry_time\"] = [];\n        results[regionKey][\"dwell_time\"] = [];\n        results[regionKey][\"exit_time\"] = [];\n    }\n    else {\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"actual_dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"exit_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n    }\n    return results;\n}\n\nfunction initializePreviousData(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    // Ensure previous_data is set up for this region.\n    if (!previous_data) {\n        previous_data = {};\n    }\n    if (results[regionKey].hasOwnProperty(\"id\")) {\n        if (!previous_data[regionKey]) {\n            previous_data[regionKey] = {};\n            previous_data[regionKey][\"id\"] = [];\n            previous_data[regionKey][\"actual_entry_time\"] = [];\n            previous_data[regionKey][\"actual_dwell_time\"] = [];\n            previous_data[regionKey][\"entry_time\"] = [];\n            previous_data[regionKey][\"dwell_time\"] = [];\n            previous_data[regionKey][\"exit_time\"] = [];\n        }\n    }\n    else {\n        if (!previous_data.hasOwnProperty(regionKey)) {\n            previous_data[regionKey] = results[regionKey];\n            previous_data[regionKey][\"actual_entry_time\"] = \"\";\n            previous_data[regionKey][\"actual_dwell_time\"] = \"\";\n            previous_data[regionKey][\"entry_time\"] = \"\";\n            previous_data[regionKey][\"dwell_time\"] = \"\";\n            previous_data[regionKey][\"exit_time\"] = \"\";\n            previous_data[regionKey][\"occupancy_check\"] = 0;\n        }\n    }\n\n    return previous_data;\n}\n\nfunction handleObjectWithID(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    const resultIds = results[regionKey][\"id\"];\n    const previousDataIds = previous_data[regionKey][\"id\"];\n\n    if (!resultIds && !previousDataIds) {\n        return results;\n    }\n\n    if (resultIds) {\n        for (let j = 0; j < resultIds.length; j++) {\n            // Check existing id data\n            let prevIndex = -1;\n\n            if (previous_data[regionKey][\"id\"] && previous_data[regionKey][\"id\"].length > 0) {\n                prevIndex = previous_data[regionKey][\"id\"].indexOf(resultIds[j]);\n            }\n\n            if (prevIndex === -1) {\n                results[regionKey][\"actual_entry_time\"].push(msg.nodered_timestamp);\n                results[regionKey][\"entry_time\"].push(msg.object_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(\"00:00:00\");\n                results[regionKey][\"dwell_time\"].push(0);\n                results[regionKey][\"exit_time\"].push(\"\");\n            } else {\n                results[regionKey][\"actual_entry_time\"].push(previous_data[regionKey][\"actual_entry_time\"][prevIndex]);\n                results[regionKey][\"entry_time\"].push(previous_data[regionKey][\"entry_time\"][prevIndex]);\n\n                // Calculate dwell time.\n                const dwell_timestamp = (msg.object_timestamp - results[regionKey][\"entry_time\"][j]);\n                const dwell_hours = Math.floor(dwell_timestamp / 3600).toString().padStart(2, \"0\");\n                const dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n                const dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n                results[regionKey][\"dwell_time\"].push(dwell_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds);\n                results[regionKey][\"exit_time\"].push(\"\");\n            }\n        }\n    }\n\n    if (previousDataIds) {\n        for (let j = 0; j < previousDataIds.length; j++) {\n            let prevIndex = -1;\n\n            if (!results[regionKey][\"id\"]) {\n                results[regionKey] = previous_data[regionKey];\n                results[regionKey][\"occupied\"] = 0;\n                break;\n            }\n            else {\n                if (!results[regionKey][\"dwell_time\"].some(val => val >= stop_duration)) {\n                    results[regionKey][\"occupied\"] = 0;\n                }\n\n                prevIndex = results[regionKey][\"id\"].indexOf(previousDataIds[j]);\n                if (prevIndex === -1) {\n                    let keyList = Object.keys(previous_data[regionKey]);\n                    for (let k = 0; k < keyList.length; k++) {\n                        if (keyList[k] == \"video_id\" || keyList[k] == \"region_id\" || keyList[k] == \"occupied\") {\n                            continue;\n                        }\n                        results[regionKey][keyList[k]].push(previous_data[regionKey][keyList[k]][j]);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction handleOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    if (previous_data[regionKey][\"entry_time\"] == \"\") {\n        results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n        results[regionKey][\"entry_time\"] = msg.object_timestamp;\n    }\n    else {\n        if (previous_data[regionKey][\"occupancy_check\"] >= occupancy_check_duration) {\n            results[regionKey][\"actual_dwell_time\"] = \"00:00:00\";\n            results[regionKey][\"dwell_time\"] = 0;\n            results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n            results[regionKey][\"entry_time\"] = msg.object_timestamp;\n        }\n        else {\n            results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n            results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n        }\n\n        var dwell_timestamp = msg.object_timestamp - results[regionKey][\"entry_time\"];\n        var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n        dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, \"0\") : dwell_hours.toString();\n        var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n        var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n\n        results[regionKey][\"dwell_time\"] = dwell_timestamp;\n        results[regionKey][\"actual_dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n        results[regionKey][\"occupancy_check\"] = 0;\n    }\n\n    return results;\n}\n\nfunction handleNotOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n    results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n    results[regionKey][\"actual_dwell_time\"] = previous_data[regionKey][\"actual_dwell_time\"];\n    results[regionKey][\"dwell_time\"] = previous_data[regionKey][\"dwell_time\"];\n    results[regionKey][\"occupancy_check\"] = previous_data[regionKey][\"occupancy_check\"] + 1;\n\n    if (previous_data[regionKey][\"exit_time\"]) {\n        results[regionKey][\"exit_time\"] = previous_data[regionKey][\"exit_time\"];\n    }\n    else {\n        results[regionKey][\"exit_time\"] = msg.nodered_timestamp;\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, intersection_type, intersection_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get(\"distance_threshold\");\nvar intersection_type = flow.get(\"intersection_type\");\nvar intersection_threshold = flow.get(\"intersection_threshold\");\nvar object_counter = flow.get(\"object_counter\");\n\nmsg.payload = main(payload, distance_threshold, intersection_type, intersection_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 980,
        "wires": [
            [
                "278333c3c226feb9",
                "deb240b2b63ec5ac"
            ]
        ]
    },
    {
        "id": "f8d561d7209fefb6",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 1",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"ID\", \"Status\", \"Type\", \"Entry Time\", \"Dwell Time\", \"Dwell Time Seconds\"];\nvar data = [\"video_id\", \"region_id\", \"id\", \"occupied\", \"roi_type\", \"actual_entry_time\", \"actual_dwell_time\", \"dwell_time\"];\nvar first_region_name = \"Region 1_1 1\";\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\nvar stop_duration = flow.get(\"stop_duration\");\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        if (payload[keys[i]].hasOwnProperty(\"id\") && payload[keys[i]][\"dwell_time\"][h] < stop_duration) {\n            if (h > 0) {\n                offset -= 1;\n            }\n            continue;\n        }\n        var region_name = \"Region \" + payload[keys[i]][data[0]] + \"_\" + payload[keys[i]][data[1]] + \" \" + (i + 1 + offset);\n        result.payload[region_name] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[region_name][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[region_name][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                if (typeof data_value === \"undefined\") {\n                    data_value = \"\";\n                }\n                result.payload[region_name][header[g]] = data_value;\n            }\n        }\n    }\n}\n\nif (Object.keys(result.payload).length == 0) {\n    result.payload[first_region_name] = { \"Status\": \"Empty\" };\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 740,
        "wires": [
            [
                "093ff9cee8868aab"
            ]
        ]
    },
    {
        "id": "2d953ea2b9cb5170",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 2",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"ID\", \"Status\", \"Type\", \"Entry Time\", \"Dwell Time\", \"Dwell Time Seconds\"];\nvar data = [\"video_id\", \"region_id\", \"id\", \"occupied\", \"roi_type\", \"actual_entry_time\", \"actual_dwell_time\", \"dwell_time\"];\nvar first_region_name = \"Region 2_1 1\";\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\nvar stop_duration = flow.get(\"stop_duration\");\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        if (payload[keys[i]].hasOwnProperty(\"id\") && payload[keys[i]][\"dwell_time\"][h] < stop_duration) {\n            if (h > 0) {\n                offset -= 1;\n            }\n            continue;\n        }\n        var region_name = \"Region \" + payload[keys[i]][data[0]] + \"_\" + payload[keys[i]][data[1]] + \" \" + (i + 1 + offset);\n        result.payload[region_name] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[region_name][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[region_name][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                if (typeof data_value === \"undefined\") {\n                    data_value = \"\";\n                }\n                result.payload[region_name][header[g]] = data_value;\n            }\n        }\n    }\n}\n\nif (Object.keys(result.payload).length == 0) {\n    result.payload[first_region_name] = { \"Status\": \"Empty\" };\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 820,
        "wires": [
            [
                "39dc4cfc10b8c436"
            ]
        ]
    },
    {
        "id": "62da09d3589a3293",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 3",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"ID\", \"Status\", \"Type\", \"Entry Time\", \"Dwell Time\", \"Dwell Time Seconds\"];\nvar data = [\"video_id\", \"region_id\", \"id\", \"occupied\", \"roi_type\", \"actual_entry_time\", \"actual_dwell_time\", \"dwell_time\"];\nvar first_region_name = \"Region 3_1 1\";\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\nvar stop_duration = flow.get(\"stop_duration\");\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        if (payload[keys[i]].hasOwnProperty(\"id\") && payload[keys[i]][\"dwell_time\"][h] < stop_duration) {\n            if (h > 0) {\n                offset -= 1;\n            }\n            continue;\n        }\n        var region_name = \"Region \" + payload[keys[i]][data[0]] + \"_\" + payload[keys[i]][data[1]] + \" \" + (i + 1 + offset);\n        result.payload[region_name] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[region_name][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[region_name][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                if (typeof data_value === \"undefined\") {\n                    data_value = \"\";\n                }\n                result.payload[region_name][header[g]] = data_value;\n            }\n        }\n    }\n}\n\nif (Object.keys(result.payload).length == 0) {\n    result.payload[first_region_name] = { \"Status\": \"Empty\" };\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 900,
        "wires": [
            [
                "8405f44e1ba1f8b8"
            ]
        ]
    },
    {
        "id": "278333c3c226feb9",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 4",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"ID\", \"Status\", \"Type\", \"Entry Time\", \"Dwell Time\", \"Dwell Time Seconds\"];\nvar data = [\"video_id\", \"region_id\", \"id\", \"occupied\", \"roi_type\", \"actual_entry_time\", \"actual_dwell_time\", \"dwell_time\"];\nvar first_region_name = \"Region 4_1 1\";\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\nvar stop_duration = flow.get(\"stop_duration\");\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        if (payload[keys[i]].hasOwnProperty(\"id\") && payload[keys[i]][\"dwell_time\"][h] < stop_duration) {\n            if (h > 0) {\n                offset -= 1;\n            }\n            continue;\n        }\n        var region_name = \"Region \" + payload[keys[i]][data[0]] + \"_\" + payload[keys[i]][data[1]] + \" \" + (i + 1 + offset);\n        result.payload[region_name] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[region_name][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[region_name][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                if (typeof data_value === \"undefined\") {\n                    data_value = \"\";\n                }\n                result.payload[region_name][header[g]] = data_value;\n            }\n        }\n    }\n}\n\nif (Object.keys(result.payload).length == 0) {\n    result.payload[first_region_name] = { \"Status\": \"Empty\" };\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 980,
        "wires": [
            [
                "56574ab7de3a4719"
            ]
        ]
    },
    {
        "id": "fa8d87c69d6ecbc7",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 5",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"ID\", \"Status\", \"Type\", \"Entry Time\", \"Dwell Time\", \"Dwell Time Seconds\"];\nvar data = [\"video_id\", \"region_id\", \"id\", \"occupied\", \"roi_type\", \"actual_entry_time\", \"actual_dwell_time\", \"dwell_time\"];\nvar first_region_name = \"Region 1_1 1\";\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\nvar stop_duration = flow.get(\"stop_duration\");\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        if (payload[keys[i]].hasOwnProperty(\"id\") && payload[keys[i]][\"dwell_time\"][h] < stop_duration) {\n            if (h > 0) {\n                offset -= 1;\n            }\n            continue;\n        }\n        var region_name = \"Region \" + payload[keys[i]][data[0]] + \"_\" + payload[keys[i]][data[1]] + \" \" + (i + 1 + offset);\n        result.payload[region_name] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[region_name][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[region_name][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                if (typeof data_value === \"undefined\") {\n                    data_value = \"\";\n                }\n                result.payload[region_name][header[g]] = data_value;\n            }\n        }\n    }\n}\n\nif (Object.keys(result.payload).length == 0) {\n    result.payload[first_region_name] = { \"Status\": \"Empty\" };\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 1060,
        "wires": [
            [
                "fded0e73f24f4063"
            ]
        ]
    }
]